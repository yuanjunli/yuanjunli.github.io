<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="NEXTB">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="NEXTB">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NEXTB">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>


  <title> NEXTB </title>
</head>


<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">NEXTB</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/27/Glide核心设计二-缓存管理/" itemprop="url">
                  Glide核心设计二:缓存管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-02-27T13:50:20+08:00" content="2017-02-27">
              2017-02-27
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/02/27/Glide核心设计二-缓存管理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/27/Glide核心设计二-缓存管理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/02/27/Glide核心设计二-缓存管理/" class="leancloud_visitors" data-flag-title="Glide核心设计二:缓存管理">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文链接：<a href="https://yuanjunli.github.io/2017/02/27/Glide%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E4%BA%8C-%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86/" target="_blank" rel="external">Glide核心设计二:缓存管理</a></p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Glide作为一个优秀的图片加载框架，缓存管理是必不可少的一部分，这篇文章主要通过各个角度、从整体设计到代码实现，深入的分析Glide的缓存管理模块，力求在同类分析Glide缓存的分析文章中<strong>脱颖而出</strong>。关于Glide的生命周期绑定，可查看Glide系列文章<a href="https://yuanjunli.github.io/2017/02/20/Glide%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E4%B8%80%EF%BC%9A%E7%9A%AE%E7%9A%AE%E8%99%BE%EF%BC%8C%E6%88%91%E4%BB%AC%E8%B5%B0/" target="_blank" rel="external">Glide核心设计一：皮皮虾，我们走</a>。</p>
<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><ol>
<li>本文分析Glide缓存管理，将以使用Glide加载网络图片为例子，如加载本地图片、Gif资源等使用不是本文的重点。因不管是何种使用方式，缓存模块都是一样的，只抓住网络加载图片这条主线，逻辑会更清晰。</li>
<li>本文将先给出Glide缓存管理整体设计的结论，然后再分析源码。</li>
</ol>
<h1 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h1><h2 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a>缓存类型</h2><p>Glide的缓存类型分为两大类，一类是Resource缓存，一类是Bitmap缓存。</p>
<h3 id="Resource缓存"><a href="#Resource缓存" class="headerlink" title="Resource缓存"></a>Resource缓存</h3><p>为什么需要缓存图片Resource，很好理解，因为图片从网络加载，将图片缓存到本地，当需要再次使用时，直接从缓存中取出而无需再次请求网络。</p>
<h4 id="三层缓存"><a href="#三层缓存" class="headerlink" title="三层缓存"></a>三层缓存</h4><p>Glide在缓存Resource使用三层缓存，包括：</p>
<ol>
<li>一级缓存：缓存被回收的资源，使用LRU算法（Least Frequently Used，最近最少使用算法）。当需要再次使用到被回收的资源，直接从内存返回。</li>
<li>二级缓存：使用弱引用缓存正在使用的资源。当系统执行gc操作时，会回收没有强引用的资源。使用弱引用缓存资源，既可以缓存正在使用的强引用资源，也不阻碍系统需要回收无引用资源。</li>
<li>三级缓存：磁盘缓存。网络图片下载成功后将以文件的形式缓存到磁盘中。</li>
</ol>
<h3 id="Bitmap缓存"><a href="#Bitmap缓存" class="headerlink" title="Bitmap缓存"></a>Bitmap缓存</h3><h4 id="Bitmap所占内存大小"><a href="#Bitmap所占内存大小" class="headerlink" title="Bitmap所占内存大小"></a>Bitmap所占内存大小</h4><p>Bitmap所占的内存大小由三部分组成：图片的宽度分辨率、高度分辨率和Bitmap质量参数。公式是：Bitmap内存大小 = (宽pix<em>长pix)</em>质量参数所占的位数。单位是字节B。</p>
<h4 id="Bitmap压缩质量参数"><a href="#Bitmap压缩质量参数" class="headerlink" title="Bitmap压缩质量参数"></a>Bitmap压缩质量参数</h4><p>质量参数决定每一个像素点用多少位(bit)来显示：</p>
<ol>
<li>ALPHA_8就是Alpha由8位组成(1B)</li>
<li>ARGB_4444就是由4个4位组成即16位(2B)</li>
<li>ARGB_8888就是由4个8位组成即32位(4B)</li>
<li>RGB_565就是R为5位，G为6位，B为5位共16位(2B)</li>
</ol>
<p>Glide默认使用RGB_565，比系统默认使用的ARGB_8888节省一半的资源，但RGB_565无法显示透明度。<br>举个例子:在手机上显示100pix*200pix的图片，解压前15KB，是使用Glide加载(默认RGB_565)Bitmap所占用的内存是：(100x200)x2B = 40000B≈40Kb,比以文件的形成存储的增加不少，因为png、jpg等格式的图片经过压缩。正因为Bitmap比较消耗内存，例如使用Recyclerview等滑动控件显示大量图片时，将大量的创建和回收Bitmap,导致内存波动影响性能。</p>
<h4 id="Bitmap缓存算法"><a href="#Bitmap缓存算法" class="headerlink" title="Bitmap缓存算法"></a>Bitmap缓存算法</h4><p>在Glide中，使用BitmapPool来缓存Bitmap,使用的也是LRU算法。当需要使用Bitmap时，从Bitmap的池子中取出合适的Bitmap,若取不到合适的，则再新创建。当Bitmap使用完后，不直接调用Bitmap.recycler()回收，而是放入Bitmap的池子。</p>
<h2 id="缓存的Key类型"><a href="#缓存的Key类型" class="headerlink" title="缓存的Key类型"></a>缓存的Key类型</h2><p>Glide的缓存使用<key,value>的形式缓存，Resource和Bitmap都是作为Value的部分，将value存储时，必须要有一个Key标识缓存的内容，根据该Key可查找、移除对应的缓存。<br><img src="https://yuanjunli.github.io/images/glide2_key_compare.png" alt="缓存的key对比"></key,value></p>
<ol>
<li>从对比中可看出，Resource三层缓存所使用的key的构造形式是一样的，包括图片id(图片的Url地址),宽高等参数来标识。对于其他参数，举一个例子理解：图片资源从网络加载后，经过解码(decode)、缓存到磁盘、从磁盘中取出、变换资源（加圆角等,transformation）、磁盘缓存变换后的图片资源、转码(transcode)显示。</li>
<li>Bitmap的缓存Key的构造相对简单得多,由长、宽的分辨率以及图片压缩参数即可唯一标示一个回收的Bitmap。当需要使用的bitmap时，在BitmapPool中查找对应的长、宽和config都一样的Bitmap并返回，而无需重新创建。</li>
</ol>
<h2 id="Resource缓存流程"><a href="#Resource缓存流程" class="headerlink" title="Resource缓存流程"></a>Resource缓存流程</h2><p>Resource包括三层缓存，通过流程图看它们之间的关系：<br><img src="https://yuanjunli.github.io/images/glide2_resource_process.png" alt="Resource加载流程"><br>因为内存缓存优于磁盘缓存，所以当需要使用资源时，先从内存缓存中查找(一级缓存和二级缓存都是内存缓存,其功能不一样，一级缓存用于在内存中缓存不是正在使用的资源，二级缓存是保存正在使用的资源)，再从磁盘缓存中查找。若都找不到，则从网络加载。</p>
<h2 id="滑动控件多图的性能优化"><a href="#滑动控件多图的性能优化" class="headerlink" title="滑动控件多图的性能优化"></a>滑动控件多图的性能优化</h2><p>不论是Resource还是Bitmap缓存，若显示的仅是部分照片，并且不存在频繁使用的场景，则使用Glide没有太大的优势。设计缓存的目的就是为了在<strong>重复显示时，更快、更省的显示图片资源</strong>。Glide有针对ListView、Recyclerview等控件加载多图时进行优化。此处讨论最常见的场景：Recyclerview显示多图，简略图如下。<br><img src="https://yuanjunli.github.io/images/glide2_recyclerview.png" alt="Glide在Recyclerview的使用"><br>如上图所示，当图5划入界面时，会复用图一的Item,设置新的图片之前，会先清空原有图片的资源，清空时会把Resource资源放入一级缓存待将来复用，同时会将回收的Bitmap放入BitmapPool中；当图5向下隐藏，图一出现时，图5的资源会放到一级缓存中，图一的资源则从一级缓存中取出，无须重新网络请求，同时所需要的Bitmap也无须重新创建，直接复用。</p>
<h2 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h2><p>BitmapPool的LRU算法流程图如下：<br><img src="https://yuanjunli.github.io/images/glide2_lru_process.png" alt="BitmapPool LRU流程"></p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>在进行代码分析前，先给出跟Glide缓存管理相关的类图(省略类的大部分变量和方法)。<br><img src="https://yuanjunli.github.io/images/glide2_diagram.png" alt="Glide缓存管理类图"><br><a href="https://www.processon.com/view/link/58b408f9e4b02ba7e0821140" target="_blank" rel="external">Glide缓存管理类图大图地址</a></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>根据以上的Glide缓存管理的结论及类图，可自主跟源码，跳过以下内容。</p>
<h2 id="Glide-with-Context-load-String-into-ImageView"><a href="#Glide-with-Context-load-String-into-ImageView" class="headerlink" title="Glide.with(Context).load(String).into(ImageView)"></a>Glide.with(Context).load(String).into(ImageView)</h2><h2 id="Glide-with-Context"><a href="#Glide-with-Context" class="headerlink" title="Glide.with(Context)"></a>Glide.with(Context)</h2><p>返回RequestManager,主要实现和Fragment、Activity生命周期的绑定,详情请看<a href="https://yuanjunli.github.io/2017/02/20/Glide%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E4%B8%80%EF%BC%9A%E7%9A%AE%E7%9A%AE%E8%99%BE%EF%BC%8C%E6%88%91%E4%BB%AC%E8%B5%B0/" target="_blank" rel="external">Glide核心设计一：皮皮虾，我们走</a>。</p>
<h2 id="load-String"><a href="#load-String" class="headerlink" title=".load(String)"></a>.load(String)</h2><p>RequestManager的load(String)方法返回DrawableTypeRequest，根据图片地址返回一个用于创建图片请求的Request的Builder,代码如下：</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> DrawableTypeRequest&lt;String&gt; <span class="title">load</span><span class="params">(String string)</span> </span>{
        <span class="keyword">return</span> (DrawableTypeRequest&lt;String&gt;) fromString().load(string); <span class="comment">//调用fromString()和load()方法</span>
    }
</code></pre>
<p>fromString()方法调用loadGeneric()方法，代码如下：</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> DrawableTypeRequest&lt;String&gt; <span class="title">fromString</span><span class="params">()</span> </span>{
       <span class="keyword">return</span> loadGeneric(String.class); 
   }

 <span class="keyword">private</span> &lt;T&gt; <span class="function">DrawableTypeRequest&lt;T&gt; <span class="title">loadGeneric</span><span class="params">(Class&lt;T&gt; modelClass)</span> </span>{
        ModelLoader&lt;T, InputStream&gt; streamModelLoader = Glide.buildStreamModelLoader(modelClass, context);
        ModelLoader&lt;T, ParcelFileDescriptor&gt; fileDescriptorModelLoader =
                Glide.buildFileDescriptorModelLoader(modelClass, context);
        <span class="keyword">if</span> (modelClass != <span class="keyword">null</span> &amp;&amp; streamModelLoader == <span class="keyword">null</span> &amp;&amp; fileDescriptorModelLoader == <span class="keyword">null</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown type "</span> + modelClass + <span class="string">". You must provide a Model of a type for"</span>
                    + <span class="string">" which there is a registered ModelLoader, if you are using a custom model, you must first call"</span>
                    + <span class="string">" Glide#register with a ModelLoaderFactory for your custom model class"</span>);
        }

        <span class="keyword">return</span> optionsApplier.apply(  <span class="comment">//传递的参数中创建了一个DrawableTypeRequest并返回该对象</span>
                <span class="keyword">new</span> DrawableTypeRequest&lt;T&gt;(modelClass, streamModelLoader, fileDescriptorModelLoader, context,
                        glide, requestTracker, lifecycle, optionsApplier));  
    }
</code></pre>
<p>DrawableTypeRequest的load()方法如下:</p>
<pre><code class="java"><span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> DrawableRequestBuilder&lt;ModelType&gt; <span class="title">load</span><span class="params">(ModelType model)</span> </span>{
       <span class="keyword">super</span>.load(model);
       <span class="keyword">return</span> <span class="keyword">this</span>;
   }
</code></pre>
<p>DrawableTypeRequest父类是DrawableRequestBuilder，父类的父类是GenericRequestBuilder，调用super.load()方法如下：</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; <span class="title">load</span><span class="params">(ModelType model)</span> </span>{
       <span class="keyword">this</span>.model = model;
       isModelSet = <span class="keyword">true</span>;
       <span class="keyword">return</span> <span class="keyword">this</span>;
   }
</code></pre>
<p>以上代码可知，缓存管理的主要实现代码并不在.load(Sting)代码，接下来继续分析<strong>.into(ImageView)</strong>代码。</p>
<h2 id="into-ImageView"><a href="#into-ImageView" class="headerlink" title=".into(ImageView)"></a>.into(ImageView)</h2><p>GenericRequestBuilder的into(ImageView)代码如下：</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> Target&lt;TranscodeType&gt; <span class="title">into</span><span class="params">(ImageView view)</span> </span>{
        Util.assertMainThread();
        <span class="keyword">if</span> (view == <span class="keyword">null</span>) { 
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You must pass in a non null View"</span>);
        }

        <span class="keyword">if</span> (!isTransformationSet &amp;&amp; view.getScaleType() != <span class="keyword">null</span>) {
            <span class="keyword">switch</span> (view.getScaleType()) {  <span class="comment">//根据图片的scaleType做相应处理</span>
                <span class="keyword">case</span> CENTER_CROP:
                    applyCenterCrop();
                    <span class="keyword">break</span>;
                <span class="keyword">case</span> FIT_CENTER:
                <span class="keyword">case</span> FIT_START:
                <span class="keyword">case</span> FIT_END:
                    applyFitCenter();
                    <span class="keyword">break</span>;
                <span class="comment">//$CASES-OMITTED$</span>
                <span class="keyword">default</span>:
                    <span class="comment">// Do nothing.</span>
            }
        }
        <span class="comment">//调用buildImageViewTarget()方法创建了一个Target类型的对象</span>
        <span class="keyword">return</span> into(glide.buildImageViewTarget(view, transcodeClass));  
    }
</code></pre>
<p>以上代码主要有两个功能：</p>
<ol>
<li>根据ScaleType进行图片的变换</li>
<li>将ImageView转换成一个Target</li>
</ol>
<p>继续查看into(Target)的代码：</p>
<pre><code class="java"><span class="keyword">public</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(Y target)</span> </span>{
       Util.assertMainThread();
       <span class="keyword">if</span> (target == <span class="keyword">null</span>) {
           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You must pass in a non null Target"</span>);
       }
       <span class="keyword">if</span> (!isModelSet) {
           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You must first set a model (try #load())"</span>);
       }

       Request previous = target.getRequest();  <span class="comment">//获取请求体Request</span>

       <span class="keyword">if</span> (previous != <span class="keyword">null</span>) { <span class="comment">//若ImageView是复用过的，则previous不为空</span>
           previous.clear(); <span class="comment">//调用clear()方法清空ImageView上的图片资源，此方法会将回收的Resource放入内存缓存中，并不在内存中清空该资源。</span>
           requestTracker.removeRequest(previous); <span class="comment">//移除老的请求</span>
           previous.recycle(); <span class="comment">//回收Request使用</span>
       }

       Request request = buildRequest(target); <span class="comment">//获取新的Request</span>
       target.setRequest(request); <span class="comment">//将新的request设置到target中</span>
       lifecycle.addListener(target); <span class="comment">//添加生命周期的监听</span>
       requestTracker.runRequest(request); <span class="comment">//启动Request</span>

       <span class="keyword">return</span> target;
   }
</code></pre>
<p>以上代码，主要将图片加载的Request绑定到Target中，若原有Target具有旧的Request,得先处理旧的Request,再绑定上新的Request。target.setRequest()和target.getRequest()最终会调用ViewTarget的setRequest()方法和getRequest()方法，代码如下：</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequest</span><span class="params">(Request request)</span> </span>{
        setTag(request);
    }
    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setTag</span><span class="params">(Object tag)</span> </span>{
                 <span class="keyword">if</span> (tagId == <span class="keyword">null</span>) {
                     isTagUsedAtLeastOnce = <span class="keyword">true</span>;
                     view.setTag(tag);<span class="comment">//调用view的setTag方法，将Request和view做绑定</span>
                 } <span class="keyword">else</span> {
                     view.setTag(tagId, tag);<span class="comment">//调用view的setTag方法，将Request和view做绑定</span>
                 }
    }
    <span class="function"><span class="keyword">public</span> Request <span class="title">getRequest</span><span class="params">()</span> </span>{
                    Object tag = getTag(); <span class="comment">//获取view 的tag</span>
                    Request request = <span class="keyword">null</span>;
                    <span class="keyword">if</span> (tag != <span class="keyword">null</span>) {
                        <span class="keyword">if</span> (tag <span class="keyword">instanceof</span> Request) {  <span class="comment">//若该tag是Request的一个实例</span>
                            request = (Request) tag; 
                        } <span class="keyword">else</span> {  <span class="comment">//用户不能给view设置tag，因为该view的tag要用于保存Glide的Request对象，否则抛出异常</span>
                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You must not call setTag() on a view Glide is targeting"</span>);
                        }
                    }
                    <span class="keyword">return</span> request;
            }
</code></pre>
<p>以上代码可知，Request通过setTag的方式和View进行绑定，当View是复用时，则Request不为空，通过Request可对原来的资源进行缓存与回收。此处通过View的setTag()方法绑定Request,可谓妙用。</p>
<p>以上代码创建了一个Request,<strong>requestTracker.runRequest(request);</strong>启动了Request，调用Request的begin()方法,该Request实例是GenericRequest，begin()代码如下：</p>
<pre><code class="java"><span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>{
        startTime = LogTime.getLogTime();
        <span class="keyword">if</span> (model == <span class="keyword">null</span>) {
            onException(<span class="keyword">null</span>);
            <span class="keyword">return</span>;
        }

        status = Status.WAITING_FOR_SIZE; <span class="comment">//设置等待图片size的宽高状态</span>
        <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) { <span class="comment">//必须要确定图片的宽高，确定了则调用onSizeReady</span>
            onSizeReady(overrideWidth, overrideHeight);
        } <span class="keyword">else</span> { <span class="comment">//设置回调，监听界面的绘制，当检测到宽高有效时，回调onSizeReady方法</span>
            target.getSize(<span class="keyword">this</span>);
        }

        <span class="keyword">if</span> (!isComplete() &amp;&amp; !isFailed() &amp;&amp; canNotifyStatusChanged()) {
            target.onLoadStarted(getPlaceholderDrawable());
        }
        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV(<span class="string">"finished run method in "</span> + LogTime.getElapsedMillis(startTime));
        }
    }
</code></pre>
<p>加载图片前，必须要确定图片的宽高，因为需要根据确定的宽高来获取资源。onSizeReady代码如下：</p>
<pre><code class="java"><span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSizeReady</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>{
        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV(<span class="string">"Got onSizeReady in "</span> + LogTime.getElapsedMillis(startTime));
        }
        <span class="keyword">if</span> (status != Status.WAITING_FOR_SIZE) {<span class="comment">//宽高没准备好，返回</span>
            <span class="keyword">return</span>;
        }
        status = Status.RUNNING;  <span class="comment">//状态改为加载运行中</span>

        width = Math.round(sizeMultiplier * width);
        height = Math.round(sizeMultiplier * height);

        ModelLoader&lt;A, T&gt; modelLoader = loadProvider.getModelLoader();
        <span class="keyword">final</span> DataFetcher&lt;T&gt; dataFetcher = modelLoader.getResourceFetcher(model, width, height);

        <span class="keyword">if</span> (dataFetcher == <span class="keyword">null</span>) {
            onException(<span class="keyword">new</span> Exception(<span class="string">"Failed to load model: \'"</span> + model + <span class="string">"\'"</span>));
            <span class="keyword">return</span>;
        }
        ResourceTranscoder&lt;Z, R&gt; transcoder = loadProvider.getTranscoder();
        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV(<span class="string">"finished setup for calling load in "</span> + LogTime.getElapsedMillis(startTime));
        }
        loadedFromMemoryCache = <span class="keyword">true</span>;
        <span class="comment">//真正的加载任务交给engine</span>
        loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,
                priority, isMemoryCacheable, diskCacheStrategy, <span class="keyword">this</span>);
        loadedFromMemoryCache = resource != <span class="keyword">null</span>;
        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV(<span class="string">"finished onSizeReady in "</span> + LogTime.getElapsedMillis(startTime));
        }
    }
</code></pre>
<p>以上代码可知，在确定宽高后，将图片加载的任务交给类型为Engine的对象engine,并调用其load方法，代码如下:</p>
<pre><code class="java"><span class="keyword">public</span> &lt;T, Z, R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(Key signature, <span class="keyword">int</span> width, <span class="keyword">int</span> height, DataFetcher&lt;T&gt; fetcher,
           DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder,
           Priority priority, <span class="keyword">boolean</span> isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb)</span> </span>{
       Util.assertMainThread();
       <span class="keyword">long</span> startTime = LogTime.getLogTime();

       <span class="keyword">final</span> String id = fetcher.getId(); <span class="comment">//该id为图片的网络地址</span>
       <span class="comment">//缓存key的组成部分，使用工厂模式</span>
       EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),
               loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),
               transcoder, loadProvider.getSourceEncoder());
       <span class="comment">//使用一级缓存，从回收的内存缓存中查找EngineResource</span>
       EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);
       <span class="keyword">if</span> (cached != <span class="keyword">null</span>) { <span class="comment">//命中则直接返回</span>
           cb.onResourceReady(cached);
           <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) {
               logWithTimeAndKey(<span class="string">"Loaded resource from cache"</span>, startTime, key);
           }
           <span class="keyword">return</span> <span class="keyword">null</span>;
       }
       <span class="comment">//从二级缓存中查找</span>
       EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);
       <span class="keyword">if</span> (active != <span class="keyword">null</span>) {<span class="comment">//命中则直接返回</span>
           cb.onResourceReady(active);
           <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) {
               logWithTimeAndKey(<span class="string">"Loaded resource from active resources"</span>, startTime, key);
           }
           <span class="keyword">return</span> <span class="keyword">null</span>;
       }

       EngineJob current = jobs.get(key);
       <span class="keyword">if</span> (current != <span class="keyword">null</span>) {<span class="comment">//该任务已经在执行，只需要添加回调接口，在任务执行完后调用接口告知即可</span>
           current.addCallback(cb);
           <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) {
               logWithTimeAndKey(<span class="string">"Added to existing load"</span>, startTime, key);
           }
           <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, current);
       }
       <span class="comment">//一级缓存和二级缓存都不命中的情况下，启动新的任务</span>
       EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);<span class="comment">//创建EngineJob</span>
       DecodeJob&lt;T, Z, R&gt; decodeJob = <span class="keyword">new</span> DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation,
               transcoder, diskCacheProvider, diskCacheStrategy, priority); <span class="comment">//创建DecodeJob</span>
       EngineRunnable runnable = <span class="keyword">new</span> EngineRunnable(engineJob, decodeJob, priority); 
       jobs.put(key, engineJob);
       engineJob.addCallback(cb);
       engineJob.start(runnable); <span class="comment">//启动EngineRunnable runnable，使用线程池FifoPriorityThreadPoolExecutor管理</span>

       <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) {
           logWithTimeAndKey(<span class="string">"Started new load"</span>, startTime, key);
       }
       <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, engineJob);
   }
</code></pre>
<p>分析至此，我们终于看到实现一级缓存和二级缓存的相关代码，可以猜测三级缓存的实现跟EngineRunnable有关。engineJob.start(runnable)会启动EngineRunnable的start()方法。代码如下：</p>
<pre><code class="java"><span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
       <span class="keyword">if</span> (isCancelled) {
           <span class="keyword">return</span>;
       }

       Exception exception = <span class="keyword">null</span>;
       Resource&lt;?&gt; resource = <span class="keyword">null</span>;
       <span class="keyword">try</span> {
           resource = decode();  <span class="comment">//调用decode()方法</span>
       } <span class="keyword">catch</span> (Exception e) {
           <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) {
               Log.v(TAG, <span class="string">"Exception decoding"</span>, e);
           }
           exception = e;
       }

       <span class="keyword">if</span> (isCancelled) { <span class="comment">//请求被取消</span>
           <span class="keyword">if</span> (resource != <span class="keyword">null</span>) {
               resource.recycle();
           }
           <span class="keyword">return</span>;
       }

       <span class="keyword">if</span> (resource == <span class="keyword">null</span>) { <span class="comment">//加载失败</span>
           onLoadFailed(exception);
       } <span class="keyword">else</span> { <span class="comment">//加载成功</span>
           onLoadComplete(resource);
       }
   }
</code></pre>
<p>查看decode()方法如下：</p>
<pre><code class="java"><span class="keyword">private</span> Resource&lt;?&gt; decode() <span class="keyword">throws</span> Exception {
        <span class="keyword">if</span> (isDecodingFromCache()) {
            <span class="keyword">return</span> decodeFromCache();  <span class="comment">//从磁盘缓存中获取</span>
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> decodeFromSource(); <span class="comment">//从网络中获取资源</span>
        }
    }
</code></pre>
<p>至此，我们看到磁盘缓存和网络请求获取图片资源的代码。查看onLoadFailed()的代码逻辑可知，默认先从磁盘获取，失败则从网络获取。</p>
<h2 id="BitmapPool缓存逻辑"><a href="#BitmapPool缓存逻辑" class="headerlink" title="BitmapPool缓存逻辑"></a>BitmapPool缓存逻辑</h2><p>以上就是Resource三层缓存的代码，接下来看BitmapPool的缓存实现代码。<br>在decodeFromSource()的代码中，会返回一个类型为BitmapResource的对象。在RecyclerView的例子中，当ImageView被复用时，会在Tag中取出Request,调用request.clear()代码。该方法最终会调用BitmapResource的recycler()方法，代码如下：</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>{
       <span class="keyword">if</span> (!bitmapPool.put(bitmap)) {
           bitmap.recycle();
       }
   }
</code></pre>
<p>该代码调用bitmapPool.put(bitmap)，bitmapPool的实例是LruBitmapPool代码如下:</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(Bitmap bitmap)</span> </span>{
       <span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) {
           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Bitmap must not be null"</span>);
       }
       <span class="keyword">if</span> (!bitmap.isMutable() || strategy.getSize(bitmap) &gt; maxSize || !allowedConfigs.contains(bitmap.getConfig())) {
           <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) {
               Log.v(TAG, <span class="string">"Reject bitmap from pool"</span>
                       + <span class="string">", bitmap: "</span> + strategy.logBitmap(bitmap)
                       + <span class="string">", is mutable: "</span> + bitmap.isMutable()
                       + <span class="string">", is allowed config: "</span> + allowedConfigs.contains(bitmap.getConfig()));
           }
           <span class="keyword">return</span> <span class="keyword">false</span>;
       }

       <span class="keyword">final</span> <span class="keyword">int</span> size = strategy.getSize(bitmap);
       strategy.put(bitmap);<span class="comment">//该strategy的实例是Lru算法</span>
       tracker.add(bitmap); <span class="comment">//log跟踪</span>

       puts++; <span class="comment">//缓存的bitmap数量标记加一</span>
       currentSize += size;<span class="comment">//缓存bitmap的总大小</span>

       <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) {
           Log.v(TAG, <span class="string">"Put bitmap in pool="</span> + strategy.logBitmap(bitmap));
       }
       dump(); <span class="comment">//仅用于Log</span>

       evict();  <span class="comment">//判断是否超出指定的内存大小，若超出则移除</span>
       <span class="keyword">return</span> <span class="keyword">true</span>;
   }
</code></pre>
<p>可以看出，正常情况下调用put方法返回true，证明缓存该Bitmap成功，缓存成功则不调用bitmap.recycler()方法。当需要使用Bitmap时，先从Bitmap中查找是否有符合条件的Bitmap。在RecyclerView中使用Glide的例子中，将大量复用宽高及Bitmap.Config都相等的Bitmap,极大的优化系统内存性能，减少频繁的创建回收Bitmap。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Glide的缓存管理至此就分析完了，主要抓住Resource和Bitmap的缓存来讲解。在代码的阅读中还发现了工厂、装饰者等设计模式。Glide的解耦给开发者提供很大的便利性，可根据自身需求设置缓存参数，例如默认Bitmap.Config、BitmapPool缓存大小等。最后，针对Glide的缓存设计，提出几点小建议：</p>
<ol>
<li>Glide虽然默认使用的Bitmap.Config是RGB_565,但在进行transform(例如圆角显示图片)时往往默认是ARGB_8888,因为RGB_565没有透明色，此时可重写圆角变换的代码，继续使用RGB_565，同时给canvas设置背景色。</li>
<li>BitmapPool缓存的Bitmap大小跟Bitmap的分辨率也有关系，在加载图片的过程中，可调用<strong>.override(width, height)</strong>指定图片的宽高，再调整ImageView控件的大小适应布局。</li>
<li>Resource的一级缓存和Bitmap都是内存缓存，虽然极大的提升了复用，但也会导致部分内存在系统执行GC时无法释放。若内存达到手机性能瓶颈，应在合适的时机调用<strong>Glide.get(this).clearMemory()</strong>释放内存。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/20/Glide核心设计一：皮皮虾，我们走/" itemprop="url">
                  Glide核心设计一：皮皮虾，我们走
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-02-20T14:42:59+08:00" content="2017-02-20">
              2017-02-20
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/02/20/Glide核心设计一：皮皮虾，我们走/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/20/Glide核心设计一：皮皮虾，我们走/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/02/20/Glide核心设计一：皮皮虾，我们走/" class="leancloud_visitors" data-flag-title="Glide核心设计一：皮皮虾，我们走">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文链接：<a href="https://yuanjunli.github.io/2017/02/20/Glide%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E4%B8%80%EF%BC%9A%E7%9A%AE%E7%9A%AE%E8%99%BE%EF%BC%8C%E6%88%91%E4%BB%AC%E8%B5%B0/" target="_blank" rel="external">Glide核心设计一：皮皮虾，我们走</a></p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote>
<p>皮皮虾，又名虾姑，是淡水中的强者。其头部的两个锤节，可以轻易破坏贝类的外壳，身体上的步足可以保证快速移动。这些优秀的品质，使它被表情包盯上。</p>
</blockquote>
<p>Glide，作为Android最优秀的图片加载框架之一，能和Activity和Fragment的生命周期绑定，是区别于其它网络框架的核心特征，也是本文分析的重点。</p>
<p>我们将此特征和皮皮虾表情包做一个类比：<br><img src="https://yuanjunli.github.io/images/glide1_ppx.png" alt="皮皮虾和Glide类比"><br>图片网络请求紧跟Activity、Fragment的生命周期，当页面不可交互时自动停止加载，当回到可交互状态时，继续加载。就像表情包（Activity、Fragment）控制皮皮虾（图片请求）一样。</p>
<h1 id="框架设计"><a href="#框架设计" class="headerlink" title="框架设计"></a>框架设计</h1><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p><strong>Glide.with(Context).load(String).into(ImageView)</strong>可实现从网络中获取图片并展示到ImageView当中。其中和页面作生命周期绑定的主要入口是<strong>Glide.with(Context)</strong>。按照一般的分析逻辑应该先分析源码，才得出结论，但因一入源码深似海，不利于整体把握，所以先给出结论。Glide.with(Context)返回的是一个<strong>RequestManager</strong>,我们来看<strong>RequestManager</strong>的类的说明注释。</p>
<blockquote>
<p>A class for managing and starting requests for Glide. Can use activity, fragment and connectivity lifecycle events to intelligently stop, start, and restart requests. Retrieve either by instantiating a new object, or to take advantage built in Activity and Fragment lifecycle handling, use the static Glide.load methods with your Fragment or Activity.</p>
</blockquote>
<p>由此可知，该类就是用于将<strong>请求</strong>和<strong>Activity或Framgent的生命周期</strong>做绑定。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>将和生命周期相关的类图如下（省略大部分类的变量和方法）：<br><img src="https://yuanjunli.github.io/images/glide1_diagram.png" alt="声明周期绑定类图"></p>
<h3 id="类的简单介绍"><a href="#类的简单介绍" class="headerlink" title="类的简单介绍"></a>类的简单介绍</h3><ol>
<li><strong>RequestManagerRetriever</strong>:该类用于创建RequestManager或在Activity、Fragment中找出已创建的RequestManager，RequestManagerRetriever是一个单例。</li>
<li><strong>RequestManagerFragment</strong>:继承Fragment,不可见，仅用于保存RequestManager，还有一个SupportRequestManagerFragment继承v4包的Fragment,功能类似。</li>
<li><strong>LifecycleListener</strong>：用于监听Activity、Fragment的生命周期事件。</li>
<li><strong>Lifecycle</strong>：用于添加LifecycleListener。</li>
<li><strong>ActivityFragmentLifecycle</strong>：实现Livecycle接口，用于通知Activity、Fragment的生命周期事件。</li>
<li><strong>RequestTracker</strong>：该类用于跟踪、取消和重新启动执行中、已完成和失败的请求。</li>
<li><strong>ConnectivityMonitor</strong>： 监听网络事件的接口，当网络状态发生变化时，影响网络请求状态，继承LifecycleListener。</li>
<li><strong>DefaultConnectivityMonitor</strong>： ConnectivityMonitor的实现类，实现监听网络状态的逻辑。</li>
<li><strong>RequestManagerConnectivityListener</strong>： 实现ConnectivityListener接口，将网络事件传递给RequestTracker。</li>
</ol>
<h3 id="类的联系"><a href="#类的联系" class="headerlink" title="类的联系"></a>类的联系</h3><p>以上对各类有一个简单的了解，接下来将重点讲清楚各类之间的联系。整个生命周期的绑定分为四部分。</p>
<ol>
<li>调用Glide.with(Context)，根据传入的Context类型创建RequestManager。Context可以为Activity、Fragment和Application。</li>
<li>在传入的参数Activity、或者Fragment中，添加一个不可见的Fragment,监听不可见Fragment的生命周期并将该事件传递给和Fragment一一绑定的RequestManager。</li>
<li>RequestManager监听到生命事件后，管理图片请求做出响应。</li>
<li>监听当网络从无到有时，RequestManager要重新启动图片请求。</li>
</ol>
<h2 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h2><p>根据以上内容可直接跟代码可跳过以下内容，印象更加深刻。</p>
<h3 id="第一部分-Glide-with-Context）"><a href="#第一部分-Glide-with-Context）" class="headerlink" title="第一部分:Glide.with(Context）"></a>第一部分:Glide.with(Context）</h3><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(Context context)</span> </span>{
        RequestManagerRetriever retriever = RequestManagerRetriever.get();
        <span class="keyword">return</span> retriever.get(context);
    }
`
</code></pre>
<p>调用RequestManagerRetriever的get方法如下：</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(Context context)</span> </span>{
        <span class="keyword">if</span> (context == <span class="keyword">null</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You cannot start a load on a null Context"</span>);
        } <span class="keyword">else</span> <span class="keyword">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class="keyword">instanceof</span> Application)) {
            <span class="keyword">if</span> (context <span class="keyword">instanceof</span> FragmentActivity) {  <span class="comment">//传入的是Fragment</span>
                <span class="keyword">return</span> get((FragmentActivity) context);
            } <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> Activity) {  <span class="comment">//传入的是Acitivity</span>
                <span class="keyword">return</span> get((Activity) context);
            } <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextWrapper) { <span class="comment">//传入的是Application</span>
                <span class="keyword">return</span> get(((ContextWrapper) context).getBaseContext());
            }
        }

        <span class="keyword">return</span> getApplicationManager(context);
    }
</code></pre>
<p>以传入参数为Activity类型为例，代码如下：</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(Activity activity)</span> </span>{
      <span class="keyword">if</span> (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) {
          <span class="keyword">return</span> get(activity.getApplicationContext());
      } <span class="keyword">else</span> {
          assertNotDestroyed(activity);
          android.app.FragmentManager fm = activity.getFragmentManager();   <span class="comment">//获取FragmentManager</span>
          <span class="keyword">return</span> fragmentGet(activity, fm); 
      }
  }
</code></pre>
<p>主要调用fragmentGet方法，代码如下：</p>
<pre><code class="java"><span class="function">RequestManager <span class="title">fragmentGet</span><span class="params">(Context context, android.app.FragmentManager fm)</span> </span>{
       RequestManagerFragment current = getRequestManagerFragment(fm); 
       RequestManager requestManager = current.getRequestManager();  <span class="comment">//根据RequestManagerFragment获取RequestManager，一个RequestManagerFragment包含一个RequestManager</span>
       <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) {  <span class="comment">//若RequestManager为空，则新建一个并且设置到RequestManagerFragment中</span>
           requestManager = <span class="keyword">new</span> RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());
           current.setRequestManager(requestManager);
       }
       <span class="keyword">return</span> requestManager;
   }
</code></pre>
<p>getRequestManagerFragment(fm)函数主要是根据FragmentManager获取Fragment,代码如下：</p>
<pre><code class="java"><span class="function">RequestManagerFragment <span class="title">getRequestManagerFragment</span><span class="params">(<span class="keyword">final</span> android.app.FragmentManager fm)</span> </span>{
       RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);  <span class="comment">//通过Tag查找</span>
       <span class="keyword">if</span> (current == <span class="keyword">null</span>) { <span class="comment">//若为空，从缓存pendingRequestManagerFragments中查找</span>
           current = pendingRequestManagerFragments.get(fm);
           <span class="keyword">if</span> (current == <span class="keyword">null</span>) { <span class="comment">//缓存中也不存在，则新建一个RequestManagerFragment，并且添加到页面中。</span>
               current = <span class="keyword">new</span> RequestManagerFragment();
               pendingRequestManagerFragments.put(fm, current);
               fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
               handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();
           }
       }
       <span class="keyword">return</span> current;
   }
</code></pre>
<p>以上就是根据传入的Context类型创建RequestManager的代码部分。</p>
<h3 id="第二部分：监听不可见Fragment的生命周期并传递给RequestManager"><a href="#第二部分：监听不可见Fragment的生命周期并传递给RequestManager" class="headerlink" title="第二部分：监听不可见Fragment的生命周期并传递给RequestManager"></a>第二部分：监听不可见Fragment的生命周期并传递给RequestManager</h3><p>添加不可见Fragment的目的，就是因为该Fragment和父类的Activity具有同样的生命周期，无须改动原有Activity的代码，即可实现生命周期的监听。<br>RequestManagerFragment生命周期相关的代码如下：</p>
<pre><code class="java"><span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>{
       <span class="keyword">super</span>.onStart();
       lifecycle.onStart(); <span class="comment">//执行lifecycle的onStart方法</span>
   }

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>{
       <span class="keyword">super</span>.onStop();
       lifecycle.onStop();<span class="comment">//执行lifecycle的onStop方法</span>
   }

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>{
       <span class="keyword">super</span>.onDestroy();
       lifecycle.onDestroy();<span class="comment">//执行lifecycle的onDestroy方法</span>
   }
</code></pre>
<p>可以看出，Fragment的声明周期的监听都转移到类型是ActivityFragmentLifecycle的变量lifecycle中的对应方法执行。查看ActivityFragmentLifecycle的代码：</p>
<pre><code class="java"><span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>{
      isStarted = <span class="keyword">true</span>;
      <span class="comment">//循环set集合lifecycleListeners中所有LifecycleListener，执行对应的onStart</span>
      <span class="keyword">for</span> (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
          lifecycleListener.onStart();
      }
  }

 <span class="comment">//省略onStop()和onDestroy()方法，和onStart()方法类似。</span>
</code></pre>
<p>set集合的LifecycleListener是如何添加进去的，看ActivityFragmentLifecycle中的代码：</p>
<pre><code class="java"><span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(LifecycleListener listener)</span> </span>{
        lifecycleListeners.add(listener);
        <span class="keyword">if</span> (isDestroyed) {<span class="comment">//如果当前页面已经被destroy，则调用对应的onDestroy</span>
            listener.onDestroy();
        } <span class="keyword">else</span> <span class="keyword">if</span> (isStarted) {<span class="comment">//如果当前页面已经开启，则调用对应的onStart</span>
            listener.onStart();
        } <span class="keyword">else</span> {  <span class="comment">//其他情况调用onStop方法</span>
            listener.onStop();
        }
    }
</code></pre>
<p>addListener(LifecycleListener listener)方法是接口Lifecycle的方法。RequestManagerFragment提供一个公有方法：</p>
<pre><code class="java"><span class="function">ActivityFragmentLifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> lifecycle;
    }
</code></pre>
<p>回看第一部分创建RequestManager时:</p>
<pre><code class="java">requestManager = <span class="keyword">new</span> RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());
</code></pre>
<p>RequestManagerFragment中的Lifecycle作为RequestManager的构造函数的参数传递给RequestManager。RequestManager构造函数如下：</p>
<pre><code class="java">RequestManager(Context context, <span class="keyword">final</span> Lifecycle lifecycle, RequestManagerTreeNode treeNode,
           RequestTracker requestTracker, ConnectivityMonitorFactory factory) {
       <span class="keyword">this</span>.context = context.getApplicationContext();
       <span class="keyword">this</span>.lifecycle = lifecycle;
       <span class="keyword">this</span>.treeNode = treeNode;
       <span class="keyword">this</span>.requestTracker = requestTracker;
       <span class="keyword">this</span>.glide = Glide.get(context);
       <span class="keyword">this</span>.optionsApplier = <span class="keyword">new</span> OptionsApplier();
       <span class="comment">//监听网络变化的类</span>
       ConnectivityMonitor connectivityMonitor = factory.build(context,
               <span class="keyword">new</span> RequestManagerConnectivityListener(requestTracker));

       <span class="comment">// If we're the application level request manager, we may be created on a background thread. In that case we</span>
       <span class="comment">// cannot risk synchronously pausing or resuming requests, so we hack around the issue by delaying adding</span>
       <span class="comment">// ourselves as a lifecycle listener by posting to the main thread. This should be entirely safe.</span>
       <span class="keyword">if</span> (Util.isOnBackgroundThread()) {
           <span class="keyword">new</span> Handler(Looper.getMainLooper()).post(<span class="keyword">new</span> Runnable() {
               <span class="meta">@Override</span>
               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                   <span class="comment">//在主线程中将当前类实现的LifecycleListener添加到lifecycle中。</span>
                   lifecycle.addListener(RequestManager.<span class="keyword">this</span>);
               }
           });
       } <span class="keyword">else</span> {
           <span class="comment">//在主线程中将当前类实现的LifecycleListener添加到lifecycle中。</span>
           lifecycle.addListener(<span class="keyword">this</span>);
       }
       lifecycle.addListener(connectivityMonitor);
   }
</code></pre>
<p>由此可见，lifecycle添加的就是RequestManager实现的LifecycleListener接口。</p>
<h3 id="第三部分：RequestManager实现LifecycleListener"><a href="#第三部分：RequestManager实现LifecycleListener" class="headerlink" title="第三部分：RequestManager实现LifecycleListener"></a>第三部分：RequestManager实现LifecycleListener</h3><p>接着查看RequestManager实现LifecycleListener的方法：</p>
<pre><code class="java"><span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>{
       <span class="comment">// onStart might not be called because this object may be created after the fragment/activity's onStart method.</span>
       resumeRequests();
   }

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>{
       pauseRequests();
   }

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>{
       requestTracker.clearRequests();
   }
</code></pre>
<p>继续进入resumeRequests()、pauseRequests()和requestTracker.clearRequests()方法可知，都是调用RequestTracker相应的方法，RequestTracker类包含一个集合的Request，该集合包含一个Activity获取一个<br>Fragment的所以图片请求，将根据RequestManagerFragment的生命周期，统一管理图片请求。</p>
<h3 id="第四部分：监听网络状态并作出相应"><a href="#第四部分：监听网络状态并作出相应" class="headerlink" title="第四部分：监听网络状态并作出相应"></a>第四部分：监听网络状态并作出相应</h3><p>RequestManager的构造函数有如下方法：</p>
<pre><code class="java"> <span class="comment">//省略部分代码...</span>
 <span class="comment">//监听网络变化的类</span>
 ConnectivityMonitor connectivityMonitor = factory.build(context,
         <span class="keyword">new</span> RequestManagerConnectivityListener(requestTracker));
 <span class="comment">//省略部分代码...</span>
lifecycle.addListener(connectivityMonitor);         
 <span class="comment">//省略部分代码...</span>
</code></pre>
<p>以上代码可看出，ConnectivityMonitor也实现了LifecycleListener。继续跟踪代码发现，factory的实例是ConnectivityMonitorFactory，在该工厂中会检查网络权限，同时创建ConnectivityMonitor的实例DefaultConnectivityMonitor。LifecycleListener接口的实现如下：</p>
<pre><code class="java"><span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>{
       register(); <span class="comment">//register（）方法为注册广播监听网络变化</span>
   }

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>{
       unregister(); <span class="comment">//解除监听广播</span>
   }

   <span class="meta">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>{
       <span class="comment">// Do nothing.</span>
   }
</code></pre>
<p>广播接收器代码如下：</p>
<pre><code class="java"><span class="keyword">private</span> <span class="keyword">final</span> BroadcastReceiver connectivityReceiver = <span class="keyword">new</span> BroadcastReceiver() {
      <span class="meta">@Override</span>
      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>{
          <span class="keyword">boolean</span> wasConnected = isConnected;
          isConnected = isConnected(context);
          <span class="keyword">if</span> (wasConnected != isConnected) {  <span class="comment">//当网络状态发生变化时，才调用listener.onConnectivityChanged()方法</span>
              listener.onConnectivityChanged(isConnected);
          }
      }
  };
</code></pre>
<p>ConnectivityListener 的实例的类型是RequestManager的内部类，代码如下：</p>
<pre><code class="java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestManagerConnectivityListener</span> <span class="keyword">implements</span> <span class="title">ConnectivityMonitor</span>.<span class="title">ConnectivityListener</span> </span>{
       <span class="keyword">private</span> <span class="keyword">final</span> RequestTracker requestTracker;

       <span class="function"><span class="keyword">public</span> <span class="title">RequestManagerConnectivityListener</span><span class="params">(RequestTracker requestTracker)</span> </span>{
           <span class="keyword">this</span>.requestTracker = requestTracker;
       }

       <span class="meta">@Override</span>
       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConnectivityChanged</span><span class="params">(<span class="keyword">boolean</span> isConnected)</span> </span>{
           <span class="keyword">if</span> (isConnected) { <span class="comment">//如果当前状态是链接状态</span>
               requestTracker.restartRequests(); <span class="comment">//重新开启图片请求</span>
           }
       }
   }
</code></pre>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>以上就是Glide实现图片加载和Activity、Fragment生命周期绑定的全部分析。会发现使用了观察者模式和工厂模式进行解耦，其中创建一个不可见的Fragment设置到需要被监控生命周期的Activity、Fragment中，最为精彩。接下来将分析Glide核心设计二：图片缓存。敬请期待。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/23/送一个内存泄漏给2016的记几/" itemprop="url">
                  送一个内存泄漏给2016的记几
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-23T19:35:47+08:00" content="2016-12-23">
              2016-12-23
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/23/送一个内存泄漏给2016的记几/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/23/送一个内存泄漏给2016的记几/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/12/23/送一个内存泄漏给2016的记几/" class="leancloud_visitors" data-flag-title="送一个内存泄漏给2016的记几">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文链接：<a href="https://yuanjunli.github.io/2016/12/23/%E9%80%81%E4%B8%80%E4%B8%AA%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%BB%992016%E7%9A%84%E8%AE%B0%E5%87%A0/" target="_blank" rel="external">送一个内存泄漏给2016的记几</a></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>年底了，看公司项目的友盟的bug列表，发现<strong>java.lang.OutOfMemoryError</strong>的问题不少，也该是时候还了。</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在解决内存泄漏的过程中，遇到一个静态变量导致的内存泄漏，关键是这代码还是自己敲的，明明已经使用弱引用，为什么还是内存泄漏了。看代码：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RtHttp</span> </span>{

    <span class="keyword">public</span> <span class="keyword">static</span> RtHttp instance = <span class="keyword">new</span> RtHttp();
    <span class="keyword">public</span> Context context;

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">with</span><span class="params">(Context context)</span></span>{
        WeakReference&lt;Context&gt; wrContext = <span class="keyword">new</span> WeakReference&lt;Context&gt;(context);
        instance.context = wrContext.get();
    }
}
</code></pre>
<p>RtHttp为封装客户端网络框架请求的入口，假设两个条件：</p>
<ol>
<li>其中传入的Context对象只能是Activity，不能使用context.getApplicationContext()（因为此RtHttp还封装了显示网络加载对话框的代码）。</li>
<li>不能在Activity onDestroy()方法中调用RtHttp.instance.context = null;</li>
</ol>
<p>已经使用了弱引用，为什么还是内存泄漏呢？<br>记几想不通，还到谷歌搜索<strong>使用弱引用依然内存泄漏</strong>，<strong>WeakReference useless</strong>,无果。</p>
<p><img src="https://yuanjunli.github.io/images/leak_despise.jpg" alt="鄙视脸"><br>如果你已经看出问题了，请直接到评论吐槽。<br>如果你没看出问题，请把引用的文章看一遍。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一个内存泄漏的问题，反映了Java基础不牢固，在学习知识和解决问题上也不够深入。一直想写一篇2016的总结，希望以此内存泄漏的问题为界，实现在2017的一个技术提升。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote>
<p><a href="https://yq.aliyun.com/articles/3009" target="_blank" rel="external">Android 内存泄漏总结</a><br><a href="http://www.jianshu.com/p/66fecc0f97e6" target="_blank" rel="external">Java内存、Android 内存泄漏</a><br><a href="http://www.jianshu.com/p/214e42fc0d37" target="_blank" rel="external">Java gc(垃圾回收机制)小结，以及Android优化建议</a><br><a href="http://www.jianshu.com/p/4a09a51d208c" target="_blank" rel="external">JVM GC垃圾回收机制</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/15/模拟服务器返回数据/" itemprop="url">
                  模拟服务器返回数据
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-15T16:35:50+08:00" content="2016-12-15">
              2016-12-15
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/15/模拟服务器返回数据/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/15/模拟服务器返回数据/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/12/15/模拟服务器返回数据/" class="leancloud_visitors" data-flag-title="模拟服务器返回数据">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</em><br>原文链接：<a href="https://yuanjunli.github.io/2016/12/15/%E6%A8%A1%E6%8B%9F%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE/" target="_blank" rel="external">模拟服务器返回数据</a></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>模拟服务器返回的数据，在以下场景具有实际意义：</p>
<blockquote>
<p>和服务器开发协商好开发接口，但服务器API尚未部署，想接口定义好就进行开发；<br>服务器已部署，返回的数据不能测试到各种情况，希望返回期待数据测试边界情况；</p>
</blockquote>
<p>如果客户端开发人员能不走服务器，通过模拟数据返回，能提升开发效率和程序质量。</p>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>本文主要讲解两种实现方式：</p>
<ol>
<li><p>使用网络分析工具拦截客户端请求，并返回伪造数据。<br>优点：无需改变客户端代码；不依赖客户端平台，android和ios都通用；<br>缺点：依赖网络分析工具；调试相对不灵活；</p>
</li>
<li><p>使用客户端网络框架拦截请求并返回。<br>优点：返回数据由客户端代码决定，灵活易于调试；<br>缺点：需要改变客户端代码；需要根据客户端网络框架进行响应处理，不同的网络框架处理不一样；</p>
</li>
</ol>
<p>对于方案一，主要使用网络分析工具Charles进行拦截并返回，对于方案二，主要讲解使用OkHttp作为网络框架，利用拦截器机制实现模拟返回。</p>
<h1 id="使用Charles模拟数据"><a href="#使用Charles模拟数据" class="headerlink" title="使用Charles模拟数据"></a>使用Charles模拟数据</h1><h2 id="准备条件"><a href="#准备条件" class="headerlink" title="准备条件"></a>准备条件</h2><ol>
<li>客户端需要连接到和电脑同一个网络(手机连接电脑发出的wifi)</li>
<li><a href="https://www.charlesproxy.com/download/" target="_blank" rel="external">官网下载安装</a></li>
</ol>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置方法参考<a href="http://shinelw.com/2016/04/21/about-charles/" target="_blank" rel="external">Charles:移动端设备网络抓包</a><br>完成配置后，可以在Charles中检测到手机的网络请求和响应。</p>
<h2 id="转接服务器地址"><a href="#转接服务器地址" class="headerlink" title="转接服务器地址"></a>转接服务器地址</h2><p><img src="https://yuanjunli.github.io/images/mock_charles.png" alt="Charles 拦截原理"><br>转接服务器地址是指，当客户端请求地址B时，本应该向指定的服务器请求数据，但Charles可拦截此ip地址，使不向服务器地址请求，并且返回另外一台服务器模拟的数据。<br>首先，我们来生成模拟返回数据的api接口；<br>打开<a href="http://www.mocky.io/" target="_blank" rel="external">mocky网址</a>,输入想伪造Body数据，点击<strong>Generate my HTTP Response</strong>按钮生成http的url地址。<br><img src="https://yuanjunli.github.io/images/mock_mocky.png" alt="mocky生成模拟地址"><br>如图，当点击<a href="http://www.mocky.io/v2/58592298240000ba087c5a92" target="_blank" rel="external">http://www.mocky.io/v2/58592298240000ba087c5a92</a> 时，返回json格式的数据。<br>有了模拟数据的api地址，接着设置需要模拟的api接口。经过配置后，Charles可检测手机的网络请求，选择需要模拟返回数据的网络请求接口，<strong>右键</strong>选择<strong>Map Remote…</strong><br>Map From为需要拦截的接口，Map To为模拟的api接口，此处我们填入<strong><a href="http://www.mocky.io/v2/58592298240000ba087c5a92" target="_blank" rel="external">http://www.mocky.io/v2/58592298240000ba087c5a92</a></strong>，如下图：<br><img src="https://yuanjunli.github.io/images/mock_mapping.png" alt="Charles 拦截ip地址"><br>选择标题栏<strong>Tool工具图标</strong>，取消选择<strong>Map Remote</strong>,再勾选<strong>Map Remote</strong>，让设置的ip地址生效。此时，当客户端请求原地址时，都会返回模拟ip地址的数据，效果图如下：<br><img src="https://yuanjunli.github.io/images/mock_success.png" alt="Charles 返回模拟数据"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上，使用Mocky网络和Charles工具实现模拟数据返回，无需改变客户端原有代码，但是，当需要改变客户端返回的数据时，则需要重新生成http模拟地址，再次设置Charles <strong>Map to</strong>内容。</p>
<h1 id="自定义OkHttp-Interceptor模拟返回"><a href="#自定义OkHttp-Interceptor模拟返回" class="headerlink" title="自定义OkHttp Interceptor模拟返回"></a>自定义OkHttp Interceptor模拟返回</h1><p>以下内容假设用户掌握OkHttp的简单使用，重点讲解自定义OkHttpInterceptor模拟返回数据。</p>
<h2 id="OkHttp拦截器"><a href="#OkHttp拦截器" class="headerlink" title="OkHttp拦截器"></a>OkHttp拦截器</h2><p><img src="https://yuanjunli.github.io/images/mock_interceptor.png" alt="OkHttp 拦截器"><br>如图，OkHttp可在Request和Response中设置任意个数的Intercepor(图中用圆圈标识)，对请求体和响应体进行处理。借助OkHttp Interceptor机制，创建一个MockIntercepor,模拟返回一个Response,虚线部分为模拟的Response。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>MockInterceptor代码如下：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span></span>{
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>{
        Gson gson = <span class="keyword">new</span> Gson();
        Response response = <span class="keyword">null</span>;
        Response.Builder responseBuilder = <span class="keyword">new</span> Response.Builder()
                .code(<span class="number">200</span>)
                .message(<span class="string">""</span>)
                .request(chain.request())
                .protocol(Protocol.HTTP_1_0)
                .addHeader(<span class="string">"content-type"</span>, <span class="string">"application/json"</span>);
        Request request = chain.request();
        <span class="keyword">if</span>(request.url().equals(<span class="string">"http://url_whitch_need_to_mock"</span>)) { <span class="comment">//拦截指定地址</span>
            String responseString = <span class="string">"{\n"</span> +    <span class="comment">//模拟数据返回body</span>
                    <span class="string">"\t\"code\": 200,\n"</span> +
                    <span class="string">"\t\"message\": \"success\",\n"</span> +
                    <span class="string">"\t\"data\": {}\n"</span> +
                    <span class="string">"}"</span>;
            responseBuilder.body(ResponseBody.create(MediaType.parse(<span class="string">"application/json"</span>), responseString.getBytes()));<span class="comment">//将数据设置到body中</span>
            response = responseBuilder.build(); <span class="comment">//builder模式构建response</span>
        }<span class="keyword">else</span>{
            response = chain.proceed(request);
        }
        <span class="keyword">return</span> response;
    }
}
</code></pre>
<p>在debug模式下，将此Interceptor添加到网络请求的OkHttp中，即可对指定的api地址进行拦截，并且返回特定的数据。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>使用OkHttp的拦截机制，可实现改变部分代码则可模拟返回数据，返回的数据可在代码中设置，可使用工厂模式将模拟数据的生成变动代码放到Factory中。依赖网络请求框架，若原项目使用OkHttp或Retrofit作为网络框架,可轻易实现模拟接口。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote>
<p><a href="http://shinelw.com/2016/04/21/about-charles/" target="_blank" rel="external">Charles:移动端设备网络抓包</a><br><a href="http://blog.csdn.net/guijiaoba/article/details/43198503" target="_blank" rel="external">利用charles模拟Http请求和响应</a><br><a href="http://www.println.net/post/Android-Hack-Retrofit-Mock-Server" target="_blank" rel="external">Hack Retrofit (2) 之 Mock Server</a><br><a href="https://github.com/square/okhttp/wiki/Interceptors" target="_blank" rel="external">OkHttp Interceptor</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/10/创建OkHttp自定义Log/" itemprop="url">
                  创建OkHttp自定义Log
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-10T14:15:27+08:00" content="2016-12-10">
              2016-12-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/10/创建OkHttp自定义Log/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/10/创建OkHttp自定义Log/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/12/10/创建OkHttp自定义Log/" class="leancloud_visitors" data-flag-title="创建OkHttp自定义Log">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文链接：<a href="https://yuanjunli.github.io/2016/12/10/%E5%88%9B%E5%BB%BAOkhttp%E8%87%AA%E5%AE%9A%E4%B9%89log/" target="_blank" rel="external">创建OkHttp自定义Log</a></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>本文重点讲解如何在使用OkHttp作为网络请求框架的前提下，如何自定义一个适合自己项目的Http Log，从而提升网络Api开发、调试效率。</p>
<h1 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h1><p>只有对Http协议有基本的了解，才能更好的调试网络接口。</p>
<h2 id="一个故事"><a href="#一个故事" class="headerlink" title="一个故事"></a>一个故事</h2><p>男女主一次偶然的机会，开始信件传情，但他们的信件并不是直接寄给对方，而是先寄到某个地点A，由地点A的主人转发。（好吧，这是《北京遇上西雅图之不二情书》的情节）。我们来看男主发信的过程：</p>
<ol>
<li>先购买有效邮票；</li>
<li>填写信件的收件人、收件地址等信息；</li>
<li>把信件放到信封里寄出去。</li>
</ol>
<p>显然，女主收到信后回复信件也是同样的流程。</p>
<h2 id="类比"><a href="#类比" class="headerlink" title="类比"></a>类比</h2><p>我们现在将Http协议的消息结构和故事主人公收发信的过程做一个类比：<br><img src="https://yuanjunli.github.io/images/httplog_struct.png" alt="类比图"><br>下面是使用Fiddler工具抓取www.xitu.io的网络请求和响应图：<br><img src="https://yuanjunli.github.io/images/httplog_xitu.png" alt="稀土网络响应图"></p>
<h2 id="Http消息结构"><a href="#Http消息结构" class="headerlink" title="Http消息结构"></a>Http消息结构</h2><p>由前面的分析可知，Http请求消息由三部分组成：</p>
<ol>
<li>请求行由3部分组成：①请求的方法,POST还是GET等；②请求路径；③Http协议</li>
<li>请求头，每一行都是name:value的结构,包含各种来自请求客服端的信息</li>
<li>请求体，提交给服务器的信息，GET方法没有此项。</li>
</ol>
<p>Http响应体跟请求体格式大致一样。</p>
<ol>
<li>请求体有协议和响应码组成，200为响应成功</li>
<li>响应头，每一行都是name:value的结构,包含各种来自服务器的信息</li>
<li>响应体，返回客户端需要的数据</li>
</ol>
<h1 id="自定义LogInterceptor"><a href="#自定义LogInterceptor" class="headerlink" title="自定义LogInterceptor"></a>自定义LogInterceptor</h1><h2 id="OkHttp-Interceptor"><a href="#OkHttp-Interceptor" class="headerlink" title="OkHttp Interceptor"></a>OkHttp Interceptor</h2><p>OkHttp的一大特点就是可以在发出请求体和收到响应体之间添加任意个数任意任意功能的拦截器，对请求体或者响应体进行操作。还是用《北京遇上西雅图之不二情书》的故事来说，那么地点A的主人就是充当拦截器的角色，在故事中他不仅转发信件，还阅读了信件的内容。</p>
<h2 id="根据需求确定需要Log的信息"><a href="#根据需求确定需要Log的信息" class="headerlink" title="根据需求确定需要Log的信息"></a>根据需求确定需要Log的信息</h2><p>Log的信息和划分两类，一类是跟业务相关的信息，一类是与业务无关。</p>
<ol>
<li><p>业务相关包括：<br>请求地址url;<br>请求头：token、sessionId;<br>请求体：POST提交的内容;<br>响应头：token/sessionId;<br>响应体：服务器返回数据;</p>
</li>
<li><p>业务无关包括：<br>网络状态码：200为正常反应;<br>网络请求时间：从发出网络请求到响应所消耗的时间;<br>网络协议:http1、http2等;<br>网络Method：POST、GET等；<br>不管是业务相关的数据还是业务无关的数据，都是来自于Http<strong>请求体和响应体的消息结构</strong>中。</p>
</li>
</ol>
<h2 id="Log效果图"><a href="#Log效果图" class="headerlink" title="Log效果图"></a>Log效果图</h2><p>以公司项目的测试服务器自动登录接口，log效果如下:</p>
<pre><code class="java"> POST
acid-&gt;<span class="number">1075</span>
userId-&gt;-<span class="number">1</span>
network code-&gt;<span class="number">200</span>
url-&gt;http:<span class="comment">//mobileapi.app100688440.twsapp.com/app/open/open.do?ACID=1075&amp;userId=-1&amp;vendorId=7999&amp;VERS=6.5.1&amp;fromType=1110</span>
time-&gt;<span class="number">84.473</span>
request headers-&gt;sessionId: 
request-&gt;{<span class="string">"data"</span>:{<span class="string">"pagenum"</span>:<span class="number">0</span>,<span class="string">"uid"</span>:-<span class="number">1</span>,<span class="string">"flag"</span>:<span class="string">"00000000"</span>},<span class="string">"requeststamp"</span>:<span class="string">"20161212151841836466"</span>}
body-&gt;{<span class="string">"code"</span>:<span class="number">200</span>,<span class="string">"responsestamp"</span>:<span class="string">"20161212151841836466"</span>,<span class="string">"data"</span>:{<span class="string">"uid"</span>:-<span class="number">1</span>,<span class="string">"nickname"</span>:<span class="string">"游客258"</span>,<span class="string">"uploadUrl"</span>:<span class="string">"http://mobileapi.app100688440.twsapp.com/uploadservlet"</span>,<span class="string">"wxUrl"</span>:<span class="string">"http://wx.app100688440.twsapp.com"</span>,<span class="string">"isEmcee"</span>:<span class="number">0</span>,<span class="string">"canLive"</span>:<span class="number">0</span>,<span class="string">"goodnum"</span>:<span class="number">0</span>,<span class="string">"index"</span>:{},<span class="string">"revGift"</span>:{},<span class="string">"msgRemind"</span>:{},<span class="string">"freshmanMission"</span>:{},<span class="string">"account"</span>:{},<span class="string">"onlineLimit"</span>:<span class="string">"600"</span>,<span class="string">"userSecretKey"</span>:<span class="string">"brjefjzw37ocw46"</span>}}
</code></pre>
<p>log解释:<br>POST:此接口使用POST方法；<br>acid:标识此接口的id,每个接口有唯一的acid，根据acid可查询到此接口的功能，例如此接口acid = 1075为自动登录接口；<br>userId:用户id<br>network code:返回200证明服务器响应成功；<br>url：此接口请求的url地址；<br>time:为响应时间，如果某接口响应时间过长，排除网络环境的原因，就可以跟服务端商量是否可优化；<br>request header：此项目需要传sessionId;<br>request:此处打印Post方法的请求体，若后台返回参数错误，检查此行log即可；<br>body:后台数据返回，采用json格式；</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="java">
<span class="comment">/**
 * 添加Log
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>{

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"LogInterceptor"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset UTF8 = Charset.forName(<span class="string">"UTF-8"</span>); <span class="comment">//urf8编码</span>

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>{  <span class="comment">//实现Interceptor接口方法</span>
        Log.d(TAG,<span class="string">"before chain,request()"</span>);
        Request request = chain.request();  <span class="comment">//获取request</span>
        String acid = request.url().queryParameter(<span class="string">"ACID"</span>); <span class="comment">//在url中获取ACID的参数值；</span>
        Response response;
        <span class="keyword">try</span> {
            <span class="keyword">long</span> t1 = System.nanoTime();
            response = chain.proceed(request); <span class="comment">//OkHttp链式调用</span>
            <span class="keyword">long</span> t2 = System.nanoTime();
            <span class="keyword">double</span> time = (t2 - t1) / <span class="number">1e6</span>d;   <span class="comment">//用请求后的时间减去请求前的时间得到耗时</span>

            String userId = request.url().queryParameter(<span class="string">"userId"</span>);
            String type = <span class="string">""</span>;
            <span class="keyword">if</span> (request.method().equals(<span class="string">"GET"</span>)) {    <span class="comment">//判断Method类型</span>
                type = <span class="string">"GET"</span>;
            } <span class="keyword">else</span> <span class="keyword">if</span> (request.method().equals(<span class="string">"POST"</span>)) {
                type = <span class="string">"POST"</span>;
            } <span class="keyword">else</span> <span class="keyword">if</span> (request.method().equals(<span class="string">"PUT"</span>)) {
                type = <span class="string">"PUT"</span>;
            } <span class="keyword">else</span> <span class="keyword">if</span> (request.method().equals(<span class="string">"DELETE"</span>)) {
                type = <span class="string">"DELETE"</span>;
            }
            BufferedSource source = response.body().source();
            source.request(Long.MAX_VALUE); <span class="comment">// Buffer the entire body.</span>
            Buffer buffer = source.buffer();
            String logStr = <span class="string">"\n--------------------"</span>.concat(TextUtils.isEmpty(acid) ? <span class="string">""</span> : acid).concat(<span class="string">"  begin--------------------\n"</span>)
                    .concat(type)
                    .concat(<span class="string">"\nacid-&gt;"</span>).concat(TextUtils.isEmpty(acid) ? <span class="string">""</span> : acid)
                    .concat(<span class="string">"\nuserId-&gt;"</span>).concat(TextUtils.isEmpty(userId) ? <span class="string">""</span> : userId)
                    .concat(<span class="string">"\nnetwork code-&gt;"</span>).concat(response.code() + <span class="string">""</span>)
                    .concat(<span class="string">"\nurl-&gt;"</span>).concat(request.url() + <span class="string">""</span>)
                    .concat(<span class="string">"\ntime-&gt;"</span>).concat(time + <span class="string">""</span>)
                    .concat(<span class="string">"\nrequest headers-&gt;"</span>).concat(request.headers() + <span class="string">""</span>)
                    .concat(<span class="string">"request-&gt;"</span>).concat(bodyToString(request.body()))
                    .concat(<span class="string">"\nbody-&gt;"</span>).concat(buffer.clone().readString(UTF8)); <span class="comment">//响应体转String</span>
            Log.i(TAG, logStr);
        } <span class="keyword">catch</span> (Exception e) {
            Log.d(TAG,e.getClass().toString()+<span class="string">", error:acid = "</span>+acid);  <span class="comment">//网络出错，log 出错的acid</span>
            <span class="keyword">throw</span> e; <span class="comment">//不拦截exception，由上层处理网络错误</span>
        }
        <span class="keyword">return</span> response;
    }

    <span class="comment">/**
     * 请求体转String
     * <span class="doctag">@param</span> request
     * <span class="doctag">@return</span>
     */</span>
    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">bodyToString</span><span class="params">(<span class="keyword">final</span> RequestBody request)</span> </span>{

        <span class="keyword">try</span> {
            <span class="keyword">final</span> Buffer buffer = <span class="keyword">new</span> Buffer();
            request.writeTo(buffer);
            <span class="keyword">return</span> buffer.readUtf8();
        } <span class="keyword">catch</span> (<span class="keyword">final</span> IOException e) {
            <span class="keyword">return</span> <span class="string">"did not work"</span>;
        }
    }

}
</code></pre>
<h2 id="开源项目okhttp-logging-interceptor"><a href="#开源项目okhttp-logging-interceptor" class="headerlink" title="开源项目okhttp-logging-interceptor"></a>开源项目okhttp-logging-interceptor</h2><p>如果不想自己编写代码，也可以使用开源项目<a href="https://github.com/square/okhttp/tree/master/okhttp-logging-interceptor" target="_blank" rel="external">okhttp-logging-interceptor</a>，支持：1.设置Log的等级；2.使用自定义Log。此开源项目也仅是一个Interceptor。但个人觉得log的样式并不适合调试使用。同时log的内容比较通用，若想突出对应项目的信息，建议还是自定义Http Log。</p>
<h2 id="Okhttp-Retrofit-Rxjava"><a href="#Okhttp-Retrofit-Rxjava" class="headerlink" title="Okhttp+Retrofit+Rxjava"></a>Okhttp+Retrofit+Rxjava</h2><p>此Interceptor配合OkHttp使用，关于Okhttp+Retrofit+Rxjava的整合，可查看<a href="https://yuanjunli.github.io/2016/11/26/rxjava+retrofit+OkHttp%E5%B0%81%E8%A3%85/" target="_blank" rel="external">RxJava+Retrofit+OkHttp封装</a></p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://github.com/square/okhttp/tree/master/okhttp-logging-interceptor" target="_blank" rel="external">okhttp-logging-interceptor</a><br><a href="https://github.com/square/okhttp/wiki/Interceptors" target="_blank" rel="external">okhttp Interceptors</a><br><a href="http://www.cnblogs.com/TankXiao/archive/2012/02/13/2342672.html" target="_blank" rel="external">Http协议详解</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/26/rxjava+retrofit+OkHttp封装/" itemprop="url">
                  RxJava+Retrofit+OkHttp封装
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-26T13:22:07+08:00" content="2016-11-26">
              2016-11-26
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/26/rxjava+retrofit+OkHttp封装/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/26/rxjava+retrofit+OkHttp封装/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/11/26/rxjava+retrofit+OkHttp封装/" class="leancloud_visitors" data-flag-title="RxJava+Retrofit+OkHttp封装">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文链接：<a href="yuanjunli.github.io/2016/11/26/rxjava+retrofit+OkHttp封装">rxjava+retrofit+OkHttp封装</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文假设读者对RxJava、Retrofit和OkHttp具有基本的了解，以项目为例，重点讲解如何优雅的封装一个网络请求框架，以适应实际项目中的使用需求。</p>
<h1 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h1><ol>
<li>支持切换网络请求地址，例如项目有分区功能，不同的分区对应不同的服务器地址</li>
<li>服务器返回接口格式不一致，有的接口是返回json格式,有的返回String格式</li>
<li>url地址中，包含固定的参数，例如版本号，渠道信息等，怎么统一添加</li>
<li>url地址中，包含动态地参数，如何动态添加</li>
<li>是否添加网络请求的Log</li>
<li>是否添加header(sessionId)</li>
<li>网络请求可配置是否显示网络加载动画</li>
<li>封装Observalbe进行数据处理的步骤，可动态改变数据处理的过程</li>
<li>封装错误处理，区分网络错误和应用层响应错误。 </li>
</ol>
<h1 id="优雅封装"><a href="#优雅封装" class="headerlink" title="优雅封装"></a>优雅封装</h1><h2 id="相互联系"><a href="#相互联系" class="headerlink" title="相互联系"></a>相互联系</h2><p>在三者的关系中，Retrofit主要负责将网络请求接口化，真正的网络请求和响应交给OkHttp，而RxJava在网络框架中扮演数据响应后进行数据处理的角色。做个简单比喻：假设用户需要从上海飞往北京中关村办事，需要办理登机、做飞机、到达北京后前往中关村。登机手续由Retrofit负责，真正的运输是由飞机(Okhttp)完成，客户到达（数据返回）选择交通工具（RtHttp）到达中关村。</p>
<h2 id="设计图"><a href="#设计图" class="headerlink" title="设计图"></a>设计图</h2><p><img src="https://yuanjunli.github.io/images/rro_frame.png" alt="设计的框架图"><br>从设计图中可看出，RtHttp为网络请求总入口：<br>问题1、2交给Retrofit Builder模式解决；<br>问题3、4、5、6交给OkHttpClient的Builer解决；<br>问题7将封装到RtHttp类中；<br>问题8由BaseApi中的Observable Builder解决；<br>问题9由ApiSubscriber的OnError方法解决。</p>
<h2 id="设计代码"><a href="#设计代码" class="headerlink" title="设计代码"></a>设计代码</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>首先，我们来看封装后的网络请求使用：</p>
<pre><code class="java">RtHttp.with(<span class="keyword">this</span>) <span class="comment">//设置Context</span>
                .setShowWaitingDialog(<span class="keyword">true</span>) <span class="comment">//设置显示网络加载动画</span>
                .setObservable(MobileApi.response(map,ProtocolUtils.PROTOCOL_MSG_ID_LOGIN))<span class="comment">//MobileApi.response 返回一个Observalbe</span>
                .subscriber(<span class="keyword">new</span> ApiSubscriber&lt;JSONObject&gt;() { <span class="comment">//设置Subscriber，ApiSubscriber封装Subscriber;返回JSONObject仅是因为适配替换成Retrofit前的老代码</span>
                    <span class="meta">@Override</span>
                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(JSONObject result)</span> </span>{    <span class="comment">//只实现OnNext方法</span>
                         <span class="comment">//具体业务逻辑</span>
                    }
                });
</code></pre>
<h3 id="RtHttp"><a href="#RtHttp" class="headerlink" title="RtHttp"></a>RtHttp</h3><p>封装后，RtHttp支持链式调用，我们来看RtHttp的代码：</p>
<pre><code class="java"><span class="comment">/**
 * 网络请求总入口
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RtHttp</span></span>{

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"RtHttp"</span>;
    <span class="keyword">public</span> <span class="keyword">static</span> RtHttp instance = <span class="keyword">new</span> RtHttp(); <span class="comment">//单例模式</span>
    <span class="keyword">private</span> Observable observable;
    <span class="keyword">private</span> <span class="keyword">static</span> WeakReference&lt;Context&gt; wrContext;
    <span class="keyword">private</span> <span class="keyword">boolean</span> isShowWaitingDialog;

    <span class="comment">/**设置Context,使用弱引用
     * <span class="doctag">@param</span> ct
     * <span class="doctag">@return</span>
     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RtHttp <span class="title">with</span><span class="params">(Context ct)</span></span>{
        wrContext = <span class="keyword">new</span> WeakReference&lt;Context&gt; (ct);
        <span class="keyword">return</span> instance;
    }

    <span class="comment">/**设置是否显示加载动画
     * <span class="doctag">@param</span> showWaitingDialog
     * <span class="doctag">@return</span>
     */</span>
    <span class="function"><span class="keyword">public</span> RtHttp <span class="title">setShowWaitingDialog</span><span class="params">(<span class="keyword">boolean</span> showWaitingDialog)</span> </span>{
        isShowWaitingDialog = showWaitingDialog;
        <span class="keyword">return</span> instance;
    }


    <span class="comment">/**设置observable
     * <span class="doctag">@param</span> observable
     * <span class="doctag">@return</span>
     */</span>
    <span class="function"><span class="keyword">public</span>  RtHttp <span class="title">setObservable</span><span class="params">(Observable observable)</span> </span>{
        <span class="keyword">this</span>.observable = observable;
        <span class="keyword">return</span> instance;
    }


    <span class="comment">/**设置ApiSubscriber
     * <span class="doctag">@param</span> subscriber
     * <span class="doctag">@return</span>
     */</span>
    <span class="function"><span class="keyword">public</span> RtHttp <span class="title">subscriber</span><span class="params">(ApiSubscriber subscriber)</span></span>{
        subscriber.setmCtx(wrContext.get());  <span class="comment">//给subscriber设置Context，用于显示网络加载动画</span>
        subscriber.setShowWaitDialog(isShowWaitingDialog); <span class="comment">//控制是否显示动画</span>
        observable.subscribe(subscriber); <span class="comment">//RxJava 方法</span>
        <span class="keyword">return</span> instance;
    }


    <span class="comment">/**
     * 使用Retrofit.Builder和OkHttpClient.Builder构建NetworkApi
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkApiBuilder</span></span>{
        <span class="keyword">private</span> String baseUrl;  <span class="comment">//根地址</span>
        <span class="keyword">private</span> <span class="keyword">boolean</span> isAddSession; <span class="comment">//是否添加sessionid</span>
        <span class="keyword">private</span> HashMap&lt;String,String&gt; addDynamicParameterMap; <span class="comment">//url动态参数</span>
        <span class="keyword">private</span> <span class="keyword">boolean</span> isAddParameter; <span class="comment">//url是否添加固定参数</span>
        <span class="keyword">private</span> Retrofit.Builder rtBuilder; 
        <span class="keyword">private</span> OkHttpClient.Builder okBuild;
        <span class="keyword">private</span> Converter.Factory convertFactory; 

        <span class="function"><span class="keyword">public</span> NetworkApiBuilder <span class="title">setConvertFactory</span><span class="params">(Converter.Factory convertFactory)</span> </span>{
            <span class="keyword">this</span>.convertFactory = convertFactory;
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }

        <span class="function"><span class="keyword">public</span> NetworkApiBuilder <span class="title">setBaseUrl</span><span class="params">(String baseUrl)</span> </span>{
            <span class="keyword">this</span>.baseUrl = baseUrl;
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }

        <span class="function"><span class="keyword">public</span> NetworkApiBuilder <span class="title">addParameter</span><span class="params">()</span></span>{
            isAddParameter = <span class="keyword">true</span>;
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }


        <span class="function"><span class="keyword">public</span> NetworkApiBuilder <span class="title">addSession</span><span class="params">()</span> </span>{
            isAddSession = <span class="keyword">true</span>;
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }

        <span class="function"><span class="keyword">public</span> NetworkApiBuilder <span class="title">addDynamicParameter</span><span class="params">(HashMap map)</span> </span>{
            addDynamicParameterMap = map;
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }


        <span class="function"><span class="keyword">public</span> NetworkApi <span class="title">build</span><span class="params">()</span></span>{
            rtBuilder= <span class="keyword">new</span> Retrofit.Builder();
            okBuild = <span class="keyword">new</span> OkHttpClient().newBuilder();
            <span class="keyword">if</span>(!TextUtils.isEmpty(baseUrl)){
                rtBuilder.baseUrl(baseUrl);
            }<span class="keyword">else</span>{
                rtBuilder.baseUrl(Mobile.getBaseUrl());
            }
            <span class="keyword">if</span>(isAddSession){
                okBuild.addInterceptor(<span class="keyword">new</span> HeaderInterceptor(wrContext.get()));
            }
            <span class="keyword">if</span>(isAddParameter){
                okBuild.addInterceptor(<span class="keyword">new</span> ParameterInterceptor());
            }
            <span class="keyword">if</span>(addDynamicParameterMap!=<span class="keyword">null</span>){
                okBuild.addInterceptor(<span class="keyword">new</span> DynamicParameterInterceptor(addDynamicParameterMap));
            }
            <span class="comment">//warning:must in the last intercepter to log the network;</span>
            <span class="keyword">if</span>(Log.isDebuggable()){ <span class="comment">//改成自己的显示log判断逻辑</span>
                okBuild.addInterceptor(<span class="keyword">new</span> LogInterceptor());
            }
            <span class="keyword">if</span>(convertFactory!=<span class="keyword">null</span>){
                rtBuilder.addConverterFactory(convertFactory);
            }<span class="keyword">else</span>{
                rtBuilder.addConverterFactory(GsonConverterFactory.create());
            }
            rtBuilder.addCallAdapterFactory(RxJavaCallAdapterFactory.create())
                     .client(okBuild.build());
            <span class="keyword">return</span> rtBuilder.build().create(NetworkApi.class);
        }
    }
}
</code></pre>
<p>RtHttp的代码很简洁，NetworkApiBuilder使用builder模式创建NetWorkApi，可以动态地配置Retrofit和OkHttpClient的参数。<br>Retrofit可配置参数：</p>
<ol>
<li>baseUrl:可通过设置baseUrl产生不同的retrofit</li>
<li>addConverterFactory：通过设置addConverterFactory可适配后台接口返回不同的数据类型，例如json和String</li>
</ol>
<p>OkHttp可添加任意Interceptor实现网络请求的处理：</p>
<ol>
<li>HeaderInterceptory用于添加header(sessionid)</li>
<li>ParameterInterceptor用于添加url固定的参数</li>
<li>DynamicParameterInterceptor用于url添加动态参数</li>
<li>LogInterceptor 用户显示log</li>
</ol>
<h3 id="MobileApi"><a href="#MobileApi" class="headerlink" title="MobileApi"></a>MobileApi</h3><p>下面我们来看Observable的创建：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MobileApi</span> <span class="keyword">extends</span> <span class="title">BaseApi</span></span>{

    <span class="keyword">public</span> <span class="keyword">static</span> NetworkApi networkApi;
    <span class="keyword">public</span> <span class="keyword">static</span> Observable obserable;

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NetworkApi <span class="title">getNetworkApi</span><span class="params">()</span> </span>{ <span class="comment">//使用NetworkApiBuilder创建networkApi</span>
        <span class="keyword">if</span>(networkApi==<span class="keyword">null</span> ){
            networkApi = <span class="keyword">new</span> RtHttp.NetworkApiBuilder()
                    .addSession()               <span class="comment">//添加sessionId</span>
                    .addParameter()             <span class="comment">//添加固定参数</span>
                    .build();
        }
        <span class="keyword">return</span> networkApi;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable <span class="title">getObserable</span><span class="params">(Observable observable)</span> </span>{   
        obserable = <span class="keyword">new</span> ObserableBuilder(observable)
                .addApiException()   <span class="comment">//添加apiExcetion过滤</span>
                .build();
        <span class="keyword">return</span> obserable;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>   Observable <span class="title">response</span><span class="params">(HashMap map, <span class="keyword">int</span> protocolId)</span> </span>{
        RequestBody body = toBody(map);
        <span class="keyword">return</span> getObserable(getNetworkApi().response(protocolId, body));
    }
}
</code></pre>
<p>getNetworkApi()方法可以创建特定的NetworkApi，getObserable添加数据返回后特定的处理。</p>
<h3 id="NetWorkApi接口定义"><a href="#NetWorkApi接口定义" class="headerlink" title="NetWorkApi接口定义"></a>NetWorkApi接口定义</h3><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NetworkApi</span> </span>{

    <span class="meta">@POST</span>(<span class="string">"open/open.do"</span>)
    <span class="function">Observable&lt;Object&gt; <span class="title">post</span><span class="params">(@Query(<span class="string">"ACID"</span>)</span> <span class="keyword">int</span> acid, @Body RequestBody  entery)</span>;

    <span class="meta">@POST</span>(<span class="string">"open/open.do"</span>)
    Observable&lt;ResponseInfo&lt;Object&gt;&gt; response(<span class="meta">@Query</span>(<span class="string">"ACID"</span>) <span class="keyword">int</span> acid, <span class="meta">@Body</span> RequestBody  entery);
}
</code></pre>
<p>acid是用于区分接口功能，RequestBody为请求的body参数。</p>
<h3 id="BaseApi"><a href="#BaseApi" class="headerlink" title="BaseApi"></a>BaseApi</h3><pre><code class="java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseApi</span> </span>{

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestBody <span class="title">toBody</span><span class="params">(HashMap map)</span> </span>{
        Gson gson = <span class="keyword">new</span> Gson();
        ImiRequestBean requestBean= <span class="keyword">new</span> ImiRequestBean();
        requestBean.setRequeststamp(ProtocolUtils.getTimestamp());
        requestBean.setData(map);
        <span class="keyword">return</span> RequestBody.create(okhttp3.MediaType.parse(<span class="string">"application/json; charset=utf-8"</span>), gson.toJson(requestBean));
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestBody <span class="title">toBody</span><span class="params">(JSONObject jsonObject)</span> </span>{
        <span class="keyword">return</span> RequestBody.create(okhttp3.MediaType.parse(<span class="string">"application/json; charset=utf-8"</span>), (jsonObject).toString());
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserableBuilder</span></span>{

        <span class="keyword">private</span> Observable observable;
        <span class="keyword">private</span> <span class="keyword">boolean</span> apiException;
        <span class="keyword">private</span> <span class="keyword">boolean</span> toJSONJbject;
        <span class="keyword">private</span> <span class="keyword">boolean</span> isWeb;
        <span class="keyword">private</span> Scheduler subscribeScheduler;
        <span class="keyword">private</span> Scheduler obscerveScheduler;

        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObscerveScheduler</span><span class="params">(Scheduler obscerveScheduler)</span> </span>{
            <span class="keyword">this</span>.obscerveScheduler = obscerveScheduler;
        }

        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSubscribeScheduler</span><span class="params">(Scheduler subscribeScheduler)</span> </span>{
            <span class="keyword">this</span>.subscribeScheduler = subscribeScheduler;
        }

        <span class="function"><span class="keyword">public</span> <span class="title">ObserableBuilder</span><span class="params">(Observable o)</span> </span>{
            <span class="keyword">this</span>.observable = o;
        }

        <span class="function"><span class="keyword">public</span> ObserableBuilder <span class="title">addApiException</span><span class="params">()</span></span>{
            apiException = <span class="keyword">true</span>;
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }
        <span class="function"><span class="keyword">public</span> ObserableBuilder <span class="title">addToJSONObject</span><span class="params">()</span></span>{
            toJSONJbject = <span class="keyword">true</span>;
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }

        <span class="function"><span class="keyword">public</span> ObserableBuilder <span class="title">isWeb</span><span class="params">()</span> </span>{
            isWeb = <span class="keyword">true</span>;
            <span class="keyword">return</span> <span class="keyword">this</span>;
        }

        <span class="function"><span class="keyword">public</span> Observable <span class="title">build</span><span class="params">()</span></span>{
            <span class="keyword">if</span>(isWeb){
                observable = observable.map(<span class="keyword">new</span> StringToJSONObjectFun1());
            }
            <span class="keyword">if</span>(apiException){
                observable = observable.flatMap(<span class="keyword">new</span> ApiThrowExcepitionFun1());
            }
            <span class="keyword">if</span>(toJSONJbject){
                observable = observable.map(<span class="keyword">new</span> ObjectToJSONObjectFun1());
            }
            <span class="keyword">if</span>(subscribeScheduler!=<span class="keyword">null</span>){
                observable = observable.subscribeOn(subscribeScheduler);
            }<span class="keyword">else</span> {
                observable = observable.subscribeOn(Schedulers.io());
            }
            <span class="keyword">if</span>(obscerveScheduler!=<span class="keyword">null</span>){
                observable = observable.observeOn(obscerveScheduler);
            }<span class="keyword">else</span>{
                observable = observable.observeOn(AndroidSchedulers.mainThread());
            }
            <span class="keyword">return</span> observable;
        }
    }
}
</code></pre>
<p>BaseApi提供toBody的方法，支持将JSONObject和HashMap转换成RequestBody。ObserableBuilder用于处理NetworkApi返回的Observalbe对象。使用ObserableBuilder可返回不同的observalbe。默认设置数据请求在子线程，处理完返回OnNext方法使用主线程。</p>
<h3 id="WebApi"><a href="#WebApi" class="headerlink" title="WebApi"></a>WebApi</h3><p>webApi跟MobileApi请求地址以及返回数据的数据都不一样，WebApi返回的数据类型是String，我们来看WebApi的代码：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebApi</span> <span class="keyword">extends</span> <span class="title">BaseApi</span> </span>{

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ROLLER = <span class="number">1</span>;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FRUIT = <span class="number">2</span>;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WX = <span class="number">3</span>;
    <span class="keyword">public</span> <span class="keyword">static</span> NetworkApi networkApi;
    <span class="keyword">public</span> <span class="keyword">static</span> Observable observable;

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NetworkApi <span class="title">getNetworkApi</span><span class="params">(String baseUrl, HashMap map)</span> </span>{
        networkApi = <span class="keyword">new</span> RtHttp.NetworkApiBuilder()
                .setBaseUrl(baseUrl)
                .addDynamicParameter(map)
                .setConvertFactory(StringConverFactory.create())
                .build();
        <span class="keyword">return</span> networkApi;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NetworkApi <span class="title">getRollerApi</span><span class="params">(HashMap map)</span> </span>{
        <span class="keyword">return</span> getNetworkApi(Web.getRollerUrl(), map);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NetworkApi <span class="title">getFruitApi</span><span class="params">(HashMap map)</span> </span>{
        <span class="keyword">return</span> getNetworkApi(Web.getFruitUrl(), map);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NetworkApi <span class="title">getWxApi</span><span class="params">(HashMap map)</span> </span>{
        <span class="keyword">return</span> getNetworkApi(Web.getWXUrl(), map);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable <span class="title">getObserable</span><span class="params">(Observable observable)</span> </span>{
        observable = <span class="keyword">new</span> ObserableBuilder(observable)
                .isWeb()
                .build();
        <span class="keyword">return</span> observable;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable <span class="title">webPost</span><span class="params">(HashMap map, String action, <span class="keyword">int</span> type)</span> </span>{
        NetworkApi networkApi = <span class="keyword">null</span>;
        <span class="keyword">if</span> (type == ROLLER) {
            networkApi = getRollerApi(map);
        } <span class="keyword">else</span> <span class="keyword">if</span> (type == FRUIT) {
            networkApi = getFruitApi(map);
        } <span class="keyword">else</span> <span class="keyword">if</span> (type == WX) {
            networkApi = getWxApi(map);
        }
        String[] str = action.split(<span class="string">"/"</span>);
        <span class="keyword">if</span> (str.length == <span class="number">1</span>) {
            observable = networkApi.webPost(str[<span class="number">0</span>]);
        } <span class="keyword">else</span> <span class="keyword">if</span> (str.length == <span class="number">2</span>) {
            observable = networkApi.webPost(str[<span class="number">0</span>], str[<span class="number">1</span>]);
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> <span class="keyword">null</span>;
        }
        <span class="keyword">return</span> getObserable(observable);
    }
}
</code></pre>
<p>getNetworkApi的参数时baseUrl和设置动态url参数 的map。getObserable的方法不使用addApiException的方法，而是使用isWeb()的方法。可以看出，变化的代码都封装在BaseApi的子类中。通过创建不同的子类，实现不同的网络请求及数据处理逻辑。</p>
<h3 id="ApiSubscriber"><a href="#ApiSubscriber" class="headerlink" title="ApiSubscriber"></a>ApiSubscriber</h3><p>ApiSubscriber封装了是否显示加载动画和对onError（）的默认处理。</p>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiSubscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; </span>{

    <span class="keyword">private</span>  Context mCtx;
    <span class="keyword">private</span> WaitingDialog waitingDialog;  <span class="comment">//加载dialog</span>
    <span class="keyword">private</span> <span class="keyword">boolean</span> isShowWaitDialog;

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShowWaitDialog</span><span class="params">(<span class="keyword">boolean</span> showWaitDialog)</span> </span>{
        isShowWaitDialog = showWaitDialog;
    }

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onStart();
        <span class="keyword">if</span>(isShowWaitDialog){
            showWaitDialog();
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmCtx</span><span class="params">(Context mCtx)</span> </span>{
        <span class="keyword">this</span>.mCtx = mCtx;
    }

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>{
        <span class="keyword">if</span>(isShowWaitDialog){
            dismissDialog();
        }
    }

    <span class="comment">/**
     * 对 onError进行处理
     * <span class="doctag">@param</span> e
     */</span>
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>{
        <span class="keyword">if</span>(isShowWaitDialog){
            dismissDialog();
        }
        Throwable throwable = e;
        <span class="keyword">if</span>(Log.isDebuggable()){
            Log.i(RtHttp.TAG,throwable.getMessage().toString());
        }
        <span class="comment">/**
         * 获取根源 异常
         */</span>
        <span class="keyword">while</span> (throwable.getCause() != <span class="keyword">null</span>){
            e = throwable;
            throwable = throwable.getCause();
        }
        <span class="keyword">if</span>(e <span class="keyword">instanceof</span> HttpException){<span class="comment">//对网络异常 弹出相应的toast</span>
            HttpException httpException = (HttpException) e;
            <span class="keyword">if</span>(TextUtils.isEmpty(httpException.getMessage())){
                ToastUtil.showToast(mCtx, R.string.imi_toast_common_net_error);
            }<span class="keyword">else</span> {
                String errorMsg = httpException.getMessage();
                <span class="keyword">if</span>(TextUtils.isEmpty(errorMsg)){
                    ToastUtil.showToast(mCtx, R.string.imi_toast_common_net_error);
                }<span class="keyword">else</span> {
                   ToastUtil.showToast(mCtx, errorMsg);
                }

            }
        }<span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> ApiException){<span class="comment">//服务器返回的错误</span>
            onResultError((ApiException) e);
        }<span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> JsonParseException
                || e <span class="keyword">instanceof</span> JSONException
                || e <span class="keyword">instanceof</span> ParseException){<span class="comment">//解析异常</span>
            ToastUtil.showToast(mCtx, R.string.imi_toast_common_parse_error);
        }<span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> UnknownHostException){
            ToastUtil.showToast(mCtx, R.string.imi_toast_common_server_error);
        }<span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> SocketTimeoutException) {
           ToastUtil.showToast(mCtx, R.string.imi_toast_common_net_timeout);
        }<span class="keyword">else</span> {
            e.printStackTrace();
            ToastUtil.showToast(mCtx, R.string.imi_toast_common_net_error);
        }
    }
    <span class="comment">/**
     * 服务器返回的错误
     * <span class="doctag">@param</span> ex
     */</span>
    <span class="function"><span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title">onResultError</span><span class="params">(ApiException ex)</span></span>{
        <span class="keyword">switch</span> (ex.getCode()){  <span class="comment">//服务器返回code默认处理</span>
            <span class="keyword">case</span> <span class="number">10021</span>:
                ToastUtil.showToast(mCtx, R.string.imi_login_input_mail_error);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">10431</span>:
                ToastUtil.showToast(mCtx, R.string.imi_const_tip_charge);
                <span class="keyword">break</span>;
            <span class="keyword">default</span>:
                String msg = ex.getMessage();
                <span class="keyword">if</span>(TextUtils.isEmpty(msg)){
                    ToastUtil.showToast(mCtx, R.string.imi_toast_common_net_error);
                }<span class="keyword">else</span> {
                    ToastUtil.showToast(mCtx, msg);
                }
        }

    }

    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dismissDialog</span><span class="params">()</span></span>{
        <span class="keyword">if</span>(waitingDialog!=<span class="keyword">null</span>) {
            <span class="keyword">if</span>(waitingDialog.isShowing()) {
                waitingDialog.dismiss();
            }
        }
    }

    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showWaitDialog</span><span class="params">()</span></span>{
        <span class="keyword">if</span> (waitingDialog == <span class="keyword">null</span>) {
            waitingDialog = <span class="keyword">new</span> WaitingDialog(mCtx);
            waitingDialog.setDialogWindowStyle();
            waitingDialog.setCanceledOnTouchOutside(<span class="keyword">false</span>);
        }
        waitingDialog.show();
    }


}
</code></pre>
<h3 id="ApiThrowExcepitionFun1"><a href="#ApiThrowExcepitionFun1" class="headerlink" title="ApiThrowExcepitionFun1"></a>ApiThrowExcepitionFun1</h3><p>使用ObservalbeBuilder中通过addApiException()的方可以法添加对服务器返回code的处理，下面来看抛出异常的代码：</p>
<pre><code class="java"><span class="comment">/**
 * 用来统一处理Http的resultCode,并将HttpResult的Data部分剥离出来返回给subscriber
 *
 * <span class="doctag">@param</span> &lt;T&gt; Subscriber真正需要的数据类型，也就是Data部分的数据类型
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiThrowExcepitionFun1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Func1</span>&lt;<span class="title">ResponseInfo</span>&lt;<span class="title">T</span>&gt;, <span class="title">Observable</span>&lt;<span class="title">T</span>&gt;&gt;</span>{

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">call</span><span class="params">(ResponseInfo&lt;T&gt; responseInfo)</span> </span>{
        <span class="keyword">if</span> (responseInfo.getCode()!= <span class="number">200</span>) {  <span class="comment">//如果code返回的不是200,则抛出ApiException异常，否则返回data数据</span>
            <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> ApiException(responseInfo.getCode(),responseInfo.getMessage()));
        }
        <span class="keyword">return</span> Observable.just(responseInfo.getData());
    }
}
</code></pre>
<h3 id="ResponseInfo"><a href="#ResponseInfo" class="headerlink" title="ResponseInfo"></a>ResponseInfo</h3><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseInfo</span>&lt;<span class="title">T</span>&gt; </span>{
    <span class="keyword">private</span> <span class="keyword">int</span> code;
    <span class="keyword">private</span> String message;
    <span class="keyword">private</span> T data;
    <span class="keyword">private</span> String responsestamp;
    <span class="function"><span class="keyword">public</span> String <span class="title">getResponsestamp</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> responsestamp;
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResponsestamp</span><span class="params">(String responsestamp)</span> </span>{
        <span class="keyword">this</span>.responsestamp = responsestamp;
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> code;
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(<span class="keyword">int</span> code)</span> </span>{
        <span class="keyword">this</span>.code = code;
    }
    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> message;
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>{
        <span class="keyword">this</span>.message = message;
    }

    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> data;
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>{
        <span class="keyword">this</span>.data = data;
    }
}
</code></pre>
<h3 id="ApiException"><a href="#ApiException" class="headerlink" title="ApiException"></a>ApiException</h3><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>{
    <span class="keyword">int</span> code;
    <span class="function"><span class="keyword">public</span> <span class="title">ApiException</span><span class="params">(<span class="keyword">int</span> code,String s)</span> </span>{
        <span class="keyword">super</span>(s);
        <span class="keyword">this</span>.code = code;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> code;
    }
}
</code></pre>
<h3 id="ParameterInterceptor"><a href="#ParameterInterceptor" class="headerlink" title="ParameterInterceptor"></a>ParameterInterceptor</h3><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span></span>{
         <span class="meta">@Override</span>
         <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>{
        Request request = chain.request();
        <span class="comment">//get请求后面追加共同的参数</span>
        HttpUrl httpUrl = request.url().newBuilder()   <span class="comment">//使用addQueryParameter()在url后面添加参数</span>
                .addQueryParameter(<span class="string">"userId"</span>, CommonData.getUid()+<span class="string">""</span>)
                .build();
        request = request.newBuilder().url(httpUrl).build();
        <span class="keyword">return</span> chain.proceed(request);
    }
}
</code></pre>
<h3 id="DynamicParameterInterceptor"><a href="#DynamicParameterInterceptor" class="headerlink" title="DynamicParameterInterceptor"></a>DynamicParameterInterceptor</h3><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicParameterInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span></span>{

    <span class="keyword">private</span> HashMap&lt;String, String&gt; map;

    <span class="function"><span class="keyword">public</span> <span class="title">DynamicParameterInterceptor</span><span class="params">(HashMap&lt;String, String&gt; map)</span> </span>{
        <span class="keyword">this</span>.map = map;
    }
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>{
        Request request = chain.request();
        <span class="comment">//get请求后面追加共同的参数</span>
        HttpUrl.Builder bulider = request.url().newBuilder();
        Iterator iter = map.entrySet().iterator();
        <span class="keyword">while</span> (iter.hasNext()) {
            Map.Entry entry = (Map.Entry) iter.next();
            bulider.addQueryParameter((String) entry.getKey(), (String) entry.getValue());
        }
        request = request.newBuilder().url(bulider.build()).build();
        <span class="keyword">return</span> chain.proceed(request);
    }
}
</code></pre>
<h3 id="HeadInterceptor"><a href="#HeadInterceptor" class="headerlink" title="HeadInterceptor"></a>HeadInterceptor</h3><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span></span>{
    <span class="keyword">private</span> Context context;
    <span class="function"><span class="keyword">public</span> <span class="title">HeaderInterceptor</span><span class="params">(Context context)</span> </span>{
        <span class="keyword">this</span>.context = context;
    }
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>{
        Request original = chain.request();
        Request.Builder requestBuilder = original.newBuilder()
                .header(<span class="string">"sessionId"</span>, CommonData.getUserInfo(context).sessionId); <span class="comment">//添加sessionId</span>
        Request request = requestBuilder.build();
        <span class="keyword">return</span> chain.proceed(request);
    }
}
</code></pre>
<h3 id="LogInterceptor"><a href="#LogInterceptor" class="headerlink" title="LogInterceptor"></a>LogInterceptor</h3><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>{

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"LogInterceptor"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset UTF8 = Charset.forName(<span class="string">"UTF-8"</span>);

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>{
        Log.d(TAG,<span class="string">"before chain,request()"</span>);
        Request request = chain.request();
        Response response;
        <span class="keyword">try</span> {
            <span class="keyword">long</span> t1 = System.nanoTime();
            response = chain.proceed(request);
            <span class="keyword">long</span> t2 = System.nanoTime();
            <span class="keyword">double</span> time = (t2 - t1) / <span class="number">1e6</span>d;
            String acid = request.url().queryParameter(<span class="string">"ACID"</span>);     <span class="comment">//本项目log特定参数项目接口acid</span>
            String userId = request.url().queryParameter(<span class="string">"userId"</span>); <span class="comment">//本项目log特定参数用户id</span>
            String type = <span class="string">""</span>;
            <span class="keyword">if</span> (request.method().equals(<span class="string">"GET"</span>)) {
                type = <span class="string">"GET"</span>;
            } <span class="keyword">else</span> <span class="keyword">if</span> (request.method().equals(<span class="string">"POST"</span>)) {
                type = <span class="string">"POST"</span>;
            } <span class="keyword">else</span> <span class="keyword">if</span> (request.method().equals(<span class="string">"PUT"</span>)) {
                type = <span class="string">"PUT"</span>;
            } <span class="keyword">else</span> <span class="keyword">if</span> (request.method().equals(<span class="string">"DELETE"</span>)) {
                type = <span class="string">"DELETE"</span>;
            }
            BufferedSource source = response.body().source();
            source.request(Long.MAX_VALUE); <span class="comment">// Buffer the entire body.</span>
            Buffer buffer = source.buffer();
            String logStr = <span class="string">"\n--------------------"</span>.concat(TextUtils.isEmpty(acid) ? <span class="string">""</span> : acid).concat(<span class="string">"  begin--------------------\n"</span>)
                    .concat(type)
                    .concat(<span class="string">"\nacid-&gt;"</span>).concat(TextUtils.isEmpty(acid) ? <span class="string">""</span> : acid)
                    .concat(<span class="string">"\nuserId-&gt;"</span>).concat(TextUtils.isEmpty(userId) ? <span class="string">""</span> : userId)
                    .concat(<span class="string">"\nnetwork code-&gt;"</span>).concat(response.code() + <span class="string">""</span>)
                    .concat(<span class="string">"\nurl-&gt;"</span>).concat(request.url() + <span class="string">""</span>)
                    .concat(<span class="string">"\ntime-&gt;"</span>).concat(time + <span class="string">""</span>)
                    .concat(<span class="string">"\nrequest headers-&gt;"</span>).concat(request.headers() + <span class="string">""</span>)
                    .concat(<span class="string">"request-&gt;"</span>).concat(bodyToString(request.body()))
                    .concat(<span class="string">"\nbody-&gt;"</span>).concat(buffer.clone().readString(UTF8));
            Log.i(RtHttp.TAG, logStr);
        } <span class="keyword">catch</span> (Exception e) {
            <span class="keyword">throw</span> e;
        }
        <span class="keyword">return</span> response;
    }
    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">bodyToString</span><span class="params">(<span class="keyword">final</span> RequestBody request)</span> </span>{

        <span class="keyword">try</span> {
            <span class="keyword">final</span> Buffer buffer = <span class="keyword">new</span> Buffer();
            request.writeTo(buffer);
            <span class="keyword">return</span> buffer.readUtf8();
        } <span class="keyword">catch</span> (<span class="keyword">final</span> IOException e) {
            <span class="keyword">return</span> <span class="string">"did not work"</span>;
        }
    }

}
</code></pre>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>我们来看，网络请求返回的log如下：</p>
<pre><code class="java">RtHttp: --------------------  begin--------------------
        POST
        acid-&gt;
        userId-&gt;<span class="number">306448537</span>
        network code-&gt;<span class="number">200</span>
        url-&gt;http:<span class="comment">//*******/user/loadInitData?userId=306448537&amp;userSecretKey=ckj5k3vrxao***ekblcru5v3r</span>
        time-&gt;<span class="number">160.708437</span>
        request headers-&gt;request-&gt;
        body-&gt;({<span class="string">"data"</span>:{<span class="string">"getTime"</span>:<span class="number">1</span>,<span class="string">"prize"</span>:[{<span class="string">"id"</span>:<span class="number">4</span>,<span class="string">"name"</span>:<span class="string">"跑车, 价值8000金豆"</span>,<span class="string">"num"</span>:<span class="string">"x1"</span>},{<span class="string">"id"</span>:<span class="number">9</span>,<span class="string">"name"</span>:<span class="string">"生日蛋糕, 价值80000金豆"</span>,<span class="string">"num"</span>:<span class="string">"x1"</span>},{<span class="string">"id"</span>:<span class="number">11</span>,<span class="string">"name"</span>:<span class="string">"爱的火山, 价值80000金豆"</span>,<span class="string">"num"</span>:<span class="string">"x1"</span>},{<span class="string">"id"</span>:<span class="number">15</span>,<span class="string">"name"</span>:<span class="string">"68888金豆"</span>,<span class="string">"num"</span>:<span class="string">"68888"</span>},{<span class="string">"id"</span>:<span class="number">63</span>,<span class="string">"name"</span>:<span class="string">"炫酷边框,发言与众不同!"</span>,<span class="string">"num"</span>:<span class="string">"x1"</span>},{<span class="string">"id"</span>:<span class="number">25</span>,<span class="string">"name"</span>:<span class="string">"中幸运石, 5分钟内中奖率中幅提升"</span>,<span class="string">"num"</span>:<span class="string">"x1"</span>},{<span class="string">"id"</span>:<span class="number">28</span>,<span class="string">"name"</span>:<span class="string">"1888阳光, 价值944金豆"</span>,<span class="string">"num"</span>:<span class="string">"1888"</span>},{<span class="string">"id"</span>:<span class="number">30</span>,<span class="string">"name"</span>:<span class="string">"自行车, 价值80000金豆"</span>,<span class="string">"num"</span>:<span class="string">"x1"</span>},{<span class="string">"id"</span>:<span class="number">59</span>,<span class="string">"name"</span>:<span class="string">"红玫瑰, 价值1000金豆"</span>,<span class="string">"num"</span>:<span class="string">"10"</span>},{<span class="string">"id"</span>:<span class="number">34</span>,<span class="string">"name"</span>:<span class="string">"超级靓号宝箱,价值700000金豆"</span>,<span class="string">"num"</span>:<span class="string">"x1"</span>},{<span class="string">"id"</span>:<span class="number">36</span>,<span class="string">"name"</span>:<span class="string">"花精灵520个, 女神的最爱"</span>,<span class="string">"num"</span>:<span class="string">"x520"</span>},{<span class="string">"id"</span>:<span class="number">38</span>,<span class="string">"name"</span>:<span class="string">"幸运星, 30分钟内中奖率极大提升"</span>,<span class="string">"num"</span>:<span class="string">"x1"</span>},{<span class="string">"id"</span>:<span class="number">40</span>,<span class="string">"name"</span>:<span class="string">"钻石项链, 价值12000金豆"</span>,<span class="string">"num"</span>:<span class="string">"x3"</span>},{<span class="string">"id"</span>:<span class="number">42</span>,<span class="string">"name"</span>:<span class="string">"水晶鞋, 价值2400金豆"</span>,<span class="string">"num"</span>:<span class="string">"x3"</span>}],<span class="string">"resetTime"</span>:<span class="number">6</span>,<span class="string">"userId"</span>:<span class="number">306448537</span>},<span class="string">"msg"</span>:<span class="string">"OK"</span>,<span class="string">"result"</span>:<span class="number">1</span>})
</code></pre>
<p>以上是封装的代码，通过使用Builder模式可以创建不同的Networkapi实例，从而满足项目中的需求及能够更好的应对变化的需求。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote>
<p><a href="http://stackoverflow.com/questions/24243410/handling-api-exceptions-in-rxjava" target="_blank" rel="external">Handling API exceptions in RxJava</a><br><a href="https://gank.io/post/56e80c2c677659311bed9841" target="_blank" rel="external">RxJava 与 Retrofit 结合的最佳实践</a><br><a href="https://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="external">给 Android 开发者的 RxJava 详解</a><br><a href="http://www.jianshu.com/p/fe89c0991aed" target="_blank" rel="external">Retrofit+RxJava+OkHttp链式封装</a><br><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="external">HTTP 协议入门</a><br><a href="http://square.github.io/okhttp/#examples" target="_blank" rel="external">OkHttp官网</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/09/不是学习工厂模式最简单的指南/" itemprop="url">
                  不是学习工厂模式最简单的指南
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-09T09:53:29+08:00" content="2016-11-09">
              2016-11-09
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/09/不是学习工厂模式最简单的指南/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/09/不是学习工厂模式最简单的指南/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/11/09/不是学习工厂模式最简单的指南/" class="leancloud_visitors" data-flag-title="不是学习工厂模式最简单的指南">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>工厂模式，简单的理解，就是封装通过new方式创建对象的代码。工厂模式可分为三类：</p>
<blockquote>
<p>简单工厂（Simple Factory）<br>工厂方法（Factory Method）<br>抽象工厂（Abstract Factory）</p>
</blockquote>
<p>本文的目的，就是通过举例理解区分三种工厂模式。</p>
<h1 id="没有工厂模式"><a href="#没有工厂模式" class="headerlink" title="没有工厂模式"></a>没有工厂模式</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>如果用户要购买Iphone手机，在没有工厂模式的情况下，用户只能自己根据手机型号来创建手机，客户代码如下：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>{

    <span class="function"><span class="keyword">public</span> Iphone <span class="title">getIphone</span><span class="params">(String type)</span> </span>{
         <span class="keyword">switch</span> (type) {
            <span class="keyword">case</span> <span class="string">"iphone5"</span>:
                <span class="keyword">return</span> <span class="keyword">new</span> Iphone5();
            <span class="keyword">case</span> <span class="string">"iphone6"</span>:
                <span class="keyword">return</span> <span class="keyword">new</span> Iphone6();
        }
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }
}
</code></pre>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当现在需要把ipone5下架，推出iphone6时，Customer代码如下：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>{

    <span class="function"><span class="keyword">public</span> Iphone <span class="title">getIphone</span><span class="params">(String type)</span> </span>{
         <span class="keyword">switch</span> (type) {
            <span class="keyword">case</span> <span class="string">"iphone6"</span>:
                <span class="keyword">return</span> <span class="keyword">new</span> Iphone6();
             <span class="keyword">case</span> <span class="string">"iphone7"</span>:
                 <span class="keyword">return</span> <span class="keyword">new</span> Iphone7();
        }
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }
}
</code></pre>
<p>简单的修改Customer端的代码，就能满足新的需求，但是，这违背了一个原则：</p>
<blockquote>
<p>设计应该”对扩展开发，对修改关闭”</p>
</blockquote>
<p>每次有新的型号，都需要改变Customer的代码，这明显是不合理，于是该普通工厂模式出现了。</p>
<h1 id="普通工厂"><a href="#普通工厂" class="headerlink" title="普通工厂"></a>普通工厂</h1><p>把创建手机变化的部分封装到一个新的类SimpleIphoneFactory，Customer代码如下：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>{

    <span class="function"><span class="keyword">public</span> Iphone <span class="title">getIphone</span><span class="params">(String type)</span> </span>{
        SimpleIphoneFactory simpleIphoneFactory = <span class="keyword">new</span> SimpleIphoneFactory();
        <span class="keyword">return</span>  simpleIphoneFactory.creatIphone(type);
    }
}
</code></pre>
<p>SimpleIphoneFactory的代码如下：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleIphoneFactory</span> </span>{

    <span class="function"><span class="keyword">public</span> Iphone <span class="title">creatIphone</span><span class="params">(String type)</span> </span>{
        <span class="keyword">switch</span> (type){
            <span class="keyword">case</span> <span class="string">"iphone6"</span>:
                <span class="keyword">return</span> <span class="keyword">new</span> Iphone6();
            <span class="keyword">case</span> <span class="string">"iphone7"</span>:
                <span class="keyword">return</span> <span class="keyword">new</span> Iphone7();
        }
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }
}
</code></pre>
<p>改变后，感觉代码并没有太大的变化。当iphone6下架，iphone8上架，还是得改变SimpleIphoneFactory的代码。<br>但是，此时Customer的代码无须改动，<strong>简单工厂方法的目的，就是把具体实例化的代码，从客户端删除</strong>。</p>
<h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>当Iphone的型号越来越多时，SimpleIphoneFactory的代码依然需要改变，Customer类符合开闭原则，SimpleIphoneFactory不符合开闭原则。下面，我们采用工厂方法，把获取手机的方法getIphone()移回Customer，解决SimpleIponeFactory依赖过多Iphone实体对象的问题。</p>
<h1 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h1><p>把用户变成抽象类，他的子类决定实例化什么类型的手机：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Iphone <span class="title">getIphone</span><span class="params">()</span></span>;
}
</code></pre>
<p>Iphone5消费者：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iphone5Customer</span> <span class="keyword">extends</span> <span class="title">Customer</span></span>{

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> Iphone <span class="title">getIphone</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Iphone5();
    }
}
</code></pre>
<p>Iphone6消费者：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iphone6Customer</span> <span class="keyword">extends</span> <span class="title">Customer</span></span>{

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> Iphone <span class="title">getIphone</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Iphone6();
    }e
}
</code></pre>
<p>下面来看不同用户获取手机的代码：</p>
<pre><code class="java"><span class="comment">//购买5的用户</span>
Customer iphone5Customer = <span class="keyword">new</span> Iphone5Customer();
iphone5Customer.getIphone();
<span class="comment">//购买6的用户</span>
Customer iphone6Customer = <span class="keyword">new</span> Iphone6Customer();
iphone5Customer.getIphone();
</code></pre>
<h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h2><p>用户获取手机，是为了使用，我们给手机添加一个startUp()方法启动手机：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Iphone</span> </span>{
    <span class="comment">/**
     * 电池毫安数
     */</span>
    <span class="keyword">protected</span> <span class="keyword">int</span> power;
    <span class="comment">/**
     * 电池
     */</span>
    <span class="keyword">protected</span> Battery battery;

    <span class="comment">/**
     * 设置电池
     * <span class="doctag">@param</span> battery
     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBattery</span><span class="params">(Battery battery)</span></span>{
        <span class="keyword">this</span>.battery = battery;
    };

    <span class="comment">/**
     * 开机
     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startUp</span><span class="params">()</span></span>;
}
</code></pre>
<p>Iphone抽象类提供一个开机的抽象方法，由子类实现。我们开看Iphone5的实体类：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iphone5</span> <span class="keyword">extends</span> <span class="title">Iphone</span></span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Iphone5"</span>;

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startUp</span><span class="params">()</span> </span>{
        <span class="keyword">if</span>(battery.power() == <span class="number">5000</span>){
            Log.d(TAG,<span class="string">"startUp success"</span>);
        }<span class="keyword">else</span>{
            Log.d(TAG,<span class="string">"Boom!!!!"</span>);
        }
    }
}
</code></pre>
<p>可以看到Iphone5实体类，当调用startUp方法时，需要判断电池的毫安数，当等于5000时，成功启动；否则会爆炸。Iphone依赖Battery,下面来看Battery抽象类：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Battery</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">power</span><span class="params">()</span></span>;
}
</code></pre>
<p>抽象类定义了一个抽象power()方法，调用此方法返回电池的毫安数。来看Iphone5Battery和Iphone6Battery的类：</p>
<pre><code class="java"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Iphone5Battery</span> <span class="keyword">extends</span> <span class="title">Battery</span></span>{
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">power</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="number">5000</span>;
    }
}

<span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Iphone6Battery</span> <span class="keyword">extends</span> <span class="title">Battery</span></span>{
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">power</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="number">10000</span>;
    }
}
</code></pre>
<p>假设，用户把iphone5的手机配上iphone6的电池(假设电池外形一样，只是毫安数不一样)，代码如下：</p>
<pre><code class="java">Customer iphone5Customer = <span class="keyword">new</span> Iphone5Customer();
Iphone iphone5 = iphone5Customer.getIphone();
iphone5.setBattery(<span class="keyword">new</span> Iphone6Battery());
iphone5.startUp();
</code></pre>
<p>毫无疑问，这会发生爆炸。<code>Log.d(TAG,&quot;Boom!!!!&quot;)</code>。为了防止爆炸，生产手机时，必须要配套生产同类型的电池。<strong>当需要约束产品类之间的关系时</strong>，抽象工厂出场了。</p>
<h1 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h1><p>Iphone稳定的产能，需要各个代工厂的生产，苹果公司制定了一套生产手机的框架来保证手机的质量，例如Iphone6的手机只能使用Iphone6的电池。苹果公司可不想像三星手机那样<strong>因电池原因</strong>发生爆炸事件。<br>我们修改Customer类如下：</p>
<pre><code class="java"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>{
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startUp</span><span class="params">(IphoneFactory iphoneFactory)</span></span>{
        iphoneFactory.startUp();
    }
}
</code></pre>
<p>Customer类提供了一个启动手机的方法，传入一个IphoneFactory对象，由IphoneFactory创建手机和对应的电池，防止因电池型号不对导致的爆炸意外。<br>IphoneFactory类如下：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IphoneFactory</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Iphone <span class="title">creatIphone</span><span class="params">()</span></span>;
    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Battery <span class="title">creatBattery</span><span class="params">()</span></span>;
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startUp</span><span class="params">()</span></span>{
         Iphone iphone = createIphone();
         Battery battery = createBattery();
         iphone.setBattery(battery);
         iphone.startUp();
    }
}
</code></pre>
<p>IphoneFactory是一个抽象类，startUp方法确定了Iphone和Battery的关系，子类实现创建Iphone和Battery的方法。看Iphone5Factory的类：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iphone5Factory</span> <span class="keyword">extends</span> <span class="title">IphoneFactory</span> </span>{

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> Iphone <span class="title">creatIphone</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Iphone5();
    }
    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> Battery <span class="title">creatBattery</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Iphone5Battery();
    }
}
</code></pre>
<p>最后我们来看启动Iphone5手机的代码：</p>
<pre><code class="java">IphoneFactory iphone5Factory = <span class="keyword">new</span> Iphone5Factory();
Customer customer = <span class="keyword">new</span> Customer();
customer.startUp(iphone5Factory);
</code></pre>
<p>可以看到，iphone5手机成功启动的Log。因为IphoneFactory封装了startUp的方法，明确了Iphone和Battery的关系，用户不能自主组装Iphone和Battery，防止了因装错电池导致事故的发生。</p>
<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><p><img src="/images/factory_simple.png" alt="简单工厂"></p>
<h2 id="工厂方法-1"><a href="#工厂方法-1" class="headerlink" title="工厂方法"></a>工厂方法</h2><p><img src="/images/factory_method.png" alt="工厂方法"></p>
<h2 id="抽象工厂-1"><a href="#抽象工厂-1" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p><img src="/images/factory_abstract.png" alt="抽象工厂"></p>
<h1 id="一句话小结"><a href="#一句话小结" class="headerlink" title="一句话小结"></a>一句话小结</h1><p>简单工厂：将创建代码从客户端移至工厂类。<br>工厂方法：用继承的方式实现，一种产品对应一个工厂类。<br>抽象工厂：系统存在产品族，且产品之间存在关系。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote>
<p><a href="http://blog.csdn.net/hguisu/article/details/7505909" target="_blank" rel="external">设计模式（一）工厂模式Factory（创建型）</a><br><a href="https://www.zhihu.com/question/20367734" target="_blank" rel="external">抽象工厂模式和工厂模式的区别？</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/19/annotation/" itemprop="url">
                  Android编译时注解实践指南
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-19T17:32:05+08:00" content="2016-10-19">
              2016-10-19
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/10/19/annotation/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/19/annotation/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/10/19/annotation/" class="leancloud_visitors" data-flag-title="Android编译时注解实践指南">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Android注解分为两种，一种是运行时注解，一种是编译时注解。RxJava就是运行时注解，而butterKnife和EventBus是编译时注解，啃代码的时候经常碰到注解，所以只能乖乖的学习。本文主要讲解演示如何在Android Studio上运行一个编译时注解的Demo，被注解的对象打印出该对象的信息。</p>
<h2 id="1-新建一个Java-Library项目"><a href="#1-新建一个Java-Library项目" class="headerlink" title="1.新建一个Java Library项目"></a>1.新建一个Java Library项目</h2><p>在Android Studio中先新建一个Android project。在Android project 中选中File-&gt;New-&gt;New Module…选择<strong>Java Library</strong>新建一个module。因为注解中用到Java库，所以必须要导入Java Library.<br><img src="/images/process_new_module.png" alt="新建Java Library"><br><img src="/images/process_java_library.png" alt="new Module..."></p>
<p>新建的Android项目名叫At(Annotation),Java Library名字是at2.<br><img src="/images/process_projcet_struct.png" alt="new Module..."></p>
<h2 id="2-编写注解类"><a href="#2-编写注解类" class="headerlink" title="2.编写注解类"></a>2.编写注解类</h2><p>在at2项目中，新建一个PrintInject，加入以下代码声明一个注解类，注解类的类型是@interface<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Author      :  yuanjunli</div><div class="line"> * Create Time :  2016/10/19 13:50</div><div class="line"> * Email       : 878715255@qq.com</div><div class="line"> */</div><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD&#125;)  <span class="comment">//声明此类可以注解的对象</span></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)                                   <span class="comment">//编译时运行</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PrintInject &#123;                                     <span class="comment">//@interface声明</span></div><div class="line">        <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;                                                <span class="comment">//定义有一个int参数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>@Target(ElementType.TYPE)   //接口、类、枚举、注解<br>@Target(ElementType.FIELD) //字段、枚举的常量<br>@Target(ElementType.METHOD) //方法</p>
<h2 id="3-注册声明方法"><a href="#3-注册声明方法" class="headerlink" title="3.注册声明方法"></a>3.注册声明方法</h2><p>在他项目中，新建一个PrintInjectProcessor，键入以下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SupportedAnnotationTypes</span>(<span class="string">"com.example.PrintInject"</span>)</div><div class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_7)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintInjectProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</div><div class="line">        Messager messager = processingEnv.getMessager();</div><div class="line">        <span class="keyword">for</span> (TypeElement te : annotations) &#123;</div><div class="line">            <span class="keyword">for</span> (Element e : roundEnv.getElementsAnnotatedWith(te)) &#123;</div><div class="line">                messager.printMessage(Diagnostic.Kind.NOTE, <span class="string">"Printing: "</span> + e.toString());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>@SupportedAnnotationTypes：指定该注解起作用的类；<br>@SupportedSourceVersion(SourceVersion.RELEASE_7)：指定jdk的版本；<br>AbstractProcessor：自定义的声明需要继承AbstractProcessor，重点实现process方法；<br>processingEnv：注解框架提供的工具集合，在此demo中取到message对象打印信息。打印的信息在android studio中<strong>Gradle Console</strong>切页中显示；<br>TypeElement：是注解的类型；<br>以上的代码就是获取所有自定义的注解并且通过<code>e.toString()</code>打印注解类的信息。</p>
<h2 id="4-创建路径文件"><a href="#4-创建路径文件" class="headerlink" title="4.创建路径文件"></a>4.创建路径文件</h2><p>在resources路径文件夹下创建一个META-INF文件夹，META-INF下面创建一个services文件夹，在里边创建一个javax.annotation.processing.Processor文件，此文件路径不能出错。在文件中写入注解路径的声明，本项目路径是<code>com.example.PrintInjectProcessor</code><br><img src="/images/process_resources_struct.png" alt="new Module..."><br>如图检查Processor放置的路径是否一样。</p>
<h2 id="5-生成编译注解at2的jar包"><a href="#5-生成编译注解at2的jar包" class="headerlink" title="5.生成编译注解at2的jar包"></a>5.生成编译注解at2的jar包</h2><p>经过以上操作，编写了一个<code>@PrintInject</code>的声明，当对象被@PrintInject声明时，在项目编译时就会打印对象的信息。接下来单独编译运行at2 这个module，导出该jar包。<br><img src="/images/process_jar.png" alt="new Module..."><br>在android studio 右侧打开Gradle切页，如果没有显示项目的gradle，点击gradle按钮编译一下，如上图，打开:at2-&gt;Tasks -&gt;build 双击里边的build文件。编译成功后会如下图所示在项目build-&gt;libs目录下生成一个at2.jar.<br><img src="/images/process_libs.png" alt="new Module..."></p>
<h2 id="6-demo测试"><a href="#6-demo测试" class="headerlink" title="6.demo测试"></a>6.demo测试</h2><p>将at2.jar copy 到at主项目的libs文件夹下，生成android项目时在app/build.gradle文件下有<code>compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])</code>为自动导入jar。编写MainActivity代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="meta">@PrintInject</span>(<span class="number">1</span>)</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>@PrintInject(1)</code>在方法onCreate()上添加注解，int参数为1。接着看编译运行demo后，message的输出并不在Message切页，也不知Log里边，是在<strong>Gradle Console</strong>下。需要注意，第一次运行项目的时候会有message输出，当再次运行时并没有，因为第二次无须再次编译，如果需要再次看到输出的信息，可以Build-&gt;Clean Project。<br><img src="/images/process_console.png" alt="new Module..."></p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><p>以上就是编译注解demo的全部内容，并不涉及注解的深入使用，只在于跑通注解的流程。</p>
<h2 id="8-引用"><a href="#8-引用" class="headerlink" title="8.引用"></a>8.引用</h2><blockquote>
<p><a href="http://blog.csdn.net/lmj623565791/article/details/43452969" target="_blank" rel="external">Android 打造编译时注解解析框架 这只是一个开始</a><br><a href="http://www.jianshu.com/p/252b0c16ffaa" target="_blank" rel="external">如何实现自定义Java编译时注解功能–初步印象</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/18/当把EventBus比喻成苹果卖手机/" itemprop="url">
                  当把EventBus比喻成苹果卖手机
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-18T09:45:50+08:00" content="2016-10-18">
              2016-10-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/10/18/当把EventBus比喻成苹果卖手机/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/18/当把EventBus比喻成苹果卖手机/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/10/18/当把EventBus比喻成苹果卖手机/" class="leancloud_visitors" data-flag-title="当把EventBus比喻成苹果卖手机">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h1><p>EventBus一直都知道这个库，但是没有接触，看到<a href="http://gold.xitu.io/entry/5783410fa633bd005b24e079" target="_blank" rel="external">国内 Top500 Android 应用分析报告</a>使用情况，觉得有必要掌握此库。EventBus是android的一个用于消息传递的库，属于订阅者模式，让发布者和订阅者解耦。本文通过对EventBus的使用，分析其内部实现。</p>
<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>关于EventBus的使用不是本文的重点，EventBus的使用请查看<a href="http://www.jianshu.com/p/da9e193e8b03" target="_blank" rel="external">EventBus使用详解</a>。</p>
<h1 id="做个比喻"><a href="#做个比喻" class="headerlink" title="做个比喻"></a>做个比喻</h1><p>为了更好的理解EventBus这个库的流程，以下将根据下图做一个比喻。<br><img src="/images/eventbus_iphone.png" alt="new Module..."><br>如上图，EventBus充当苹果公司销售部的角色。当苹果公司(Publisher发布者)生产(调用post方法)出某一款手机(EventType)时，消息会传递到销售部，由销售部告诉用户（Subscriber订阅者）。例如用户想购买iphone8，该用户必须要预约(方法被@Subscriber注解)，当销售部接到公司说iphone8开始售卖了，那么只有预约手机的用户可以购买(订阅方法被调用)。</p>
<h1 id="阅读源码"><a href="#阅读源码" class="headerlink" title="阅读源码"></a>阅读源码</h1><h2 id="EventBus-getDefault-register-this"><a href="#EventBus-getDefault-register-this" class="headerlink" title="EventBus.getDefault().register(this);"></a>EventBus.getDefault().register(this);</h2><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>{
     <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) {
         <span class="keyword">synchronized</span> (EventBus.class) {
             <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) {
                 defaultInstance = <span class="keyword">new</span> EventBus();  <span class="comment">//调用默认构造函数构建单例</span>
             }
         }
     }
     <span class="keyword">return</span> defaultInstance;
 }
</code></pre>
<p>看new EventBus做了什么初始化工作：</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>{
        <span class="keyword">this</span>(DEFAULT_BUILDER);
    }
</code></pre>
<p>空构造函数引用带参数的构造函数，参数类型是EventBusBuilder：</p>
<pre><code class="java">EventBus(EventBusBuilder builder) {
       subscriptionsByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();
       typesBySubscriber = <span class="keyword">new</span> HashMap&lt;&gt;();          
       stickyEvents = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();     
       mainThreadPoster = <span class="keyword">new</span> HandlerPoster(<span class="keyword">this</span>, Looper.getMainLooper(), <span class="number">10</span>);  
       backgroundPoster = <span class="keyword">new</span> BackgroundPoster(<span class="keyword">this</span>);                    
       asyncPoster = <span class="keyword">new</span> AsyncPoster(<span class="keyword">this</span>);            
       indexCount = builder.subscriberInfoIndexes != <span class="keyword">null</span> ? builder.subscriberInfoIndexes.size() : <span class="number">0</span>;    
       subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes,
               builder.strictMethodVerification, builder.ignoreGeneratedIndex);
       logSubscriberExceptions = builder.logSubscriberExceptions;   
       logNoSubscriberMessages = builder.logNoSubscriberMessages;
       sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;
       sendNoSubscriberEvent = builder.sendNoSubscriberEvent;
       throwSubscriberException = builder.throwSubscriberException;
       eventInheritance = builder.eventInheritance;
       executorService = builder.executorService;
   }
</code></pre>
<p>通过使用默认构造器EventBusBuilder，默认配置了一些参数,部分重点参数会接下来在阅读源码中提到。</p>
<h3 id="register-Object-subscriber"><a href="#register-Object-subscriber" class="headerlink" title="register(Object subscriber)"></a>register(Object subscriber)</h3><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>{
    Class&lt;?&gt; subscriberClass = subscriber.getClass();
    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) {
            subscribe(subscriber, subscriberMethod);
        }
    }
}
</code></pre>
<p>调用register方法，可以看到参数是一个Object,EventBus支持Activity、Fragment、Service、BroadcastReceiver等之间传递消息。<br>调用subscriber.getClass()返回subscriber对象的运行时类的Java.lang.Class。<br>根据subscriber运行时的类获取该类所以的SubscriberMethod，就是该类被@Subscriber注解的所有方法。<br>通过循环该类所有的的被注解的方法，通过调用subscriber(subscriber, subscriberMethod)方法绑定subscriber和subscriberMethod的关系。</p>
<h3 id="subscribe-subscriber-subscriberMethod"><a href="#subscribe-subscriber-subscriberMethod" class="headerlink" title="subscribe(subscriber, subscriberMethod);"></a>subscribe(subscriber, subscriberMethod);</h3><pre><code class="java"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>{
    <span class="comment">//获取subsrciberMethod传递的自定义EventType参数的运行时的类</span>
    Class&lt;?&gt; eventType = subscriberMethod.eventType;
    <span class="comment">//Subscription用于绑定subscriber和sucriberMethod,一个订阅者可以有多个subscriberMethod</span>
    Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);
    <span class="comment">//根据EventType的运行时类取到该类所有的subscriptioins，subscriptionsByEventType是HashMap中的key</span>
    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);
    <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) {
         subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();
         <span class="comment">//若根据EventType找不到subscriptions,则eventType作key,subscriptions作value添加到subscriptionByEventType中。</span>
         subscriptionsByEventType.put(eventType, subscriptions);
    } <span class="keyword">else</span> {
         <span class="keyword">if</span> (subscriptions.contains(newSubscription)) {
         <span class="comment">//已经存在newSubscription，抛出异常该订阅者已经注册，不可重复注册同一个subscriber</span>
             <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span>
                     + eventType);
         }
    }

    <span class="keyword">int</span> size = subscriptions.size();
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) {
        <span class="comment">//循环subscriptions，根据标记优先级的priority从高到低，将新的subscription插入到subscriptions中</span>
        <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) {
            subscriptions.add(i, newSubscription);
            <span class="keyword">break</span>;
        }
    }
    <span class="comment">//typesBySubscriber是一个HashMap，根据subscriber做key,获取该subscriber对应的所有的订阅事件的类型</span>
    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);
      <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) {
          subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();
          <span class="comment">//该订阅者之前的订阅事件类型列表为空，则将当前订阅类型添加到typesBySubscriber中</span>
          typesBySubscriber.put(subscriber, subscribedEvents);
      }
    subscribedEvents.add(eventType);
    <span class="comment">//如果该方法被标识为sticky事件</span>
    <span class="keyword">if</span> (subscriberMethod.sticky) {
         <span class="keyword">if</span> (eventInheritance) { eventInheritance标识是否考虑EventType的类层次结构
              <span class="comment">//循环所有的sticky黏性事件</span>
              Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();
              <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) {
                  Class&lt;?&gt; candidateEventType = entry.getKey();
                  <span class="comment">//如果当前事件是其他事件的同类型的或者是他们的父类</span>
                  <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) {
                     Object stickyEvent = entry.getValue();
                     heckPostStickyEventToSubscription(newSubscription, stickyEvent);
                  }
              }
         } <span class="keyword">else</span> {
             Object stickyEvent = stickyEvents.get(eventType);
             checkPostStickyEventToSubscription(newSubscription, stickyEvent);
         }
    }
}
</code></pre>
<p>关键代码以上都有注释。<br>黏性事件，主要使用场景是：当订阅者尚未创建，先调用EventBus.getDefault().postSticky()方法发送一个sticky事件，该事件会被stickyEvents缓存起来，当订阅该事件的类调用register()方法时，同样可以收到该事件。而调用EventBus.getDefault().post()则必须先调用register()，才能收到事件。</p>
<h3 id="checkPostStickyEventToSubscription-newSubscription-stickyEvent"><a href="#checkPostStickyEventToSubscription-newSubscription-stickyEvent" class="headerlink" title="checkPostStickyEventToSubscription(newSubscription, stickyEvent);"></a>checkPostStickyEventToSubscription(newSubscription, stickyEvent);</h3><pre><code class="java"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPostStickyEventToSubscription</span><span class="params">(Subscription newSubscription, Object stickyEvent)</span> </span>{
        <span class="keyword">if</span> (stickyEvent != <span class="keyword">null</span>) {
            <span class="comment">// If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)</span>
            <span class="comment">// --&gt; Strange corner case, which we don't take care of here.</span>
            postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());
        }
    }
</code></pre>
<h3 id="跳转postToSubscription方法"><a href="#跳转postToSubscription方法" class="headerlink" title="跳转postToSubscription方法;"></a>跳转postToSubscription方法;</h3><pre><code class="java"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>{
       <span class="comment">//根据@subscriber中threadMode进行区分，POSTING为当前线程执行，</span>
       <span class="comment">//MAIN为主线程，BACKGROUND为子进程，ASYNC为异步执行。</span>
       <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) {
           <span class="keyword">case</span> POSTING:
               invokeSubscriber(subscription, event);
               <span class="keyword">break</span>;
           <span class="keyword">case</span> MAIN:
               <span class="keyword">if</span> (isMainThread) {
                   invokeSubscriber(subscription, event);
               } <span class="keyword">else</span> {
                   mainThreadPoster.enqueue(subscription, event);
               }
               <span class="keyword">break</span>;
           <span class="keyword">case</span> BACKGROUND:
               <span class="keyword">if</span> (isMainThread) {
                   backgroundPoster.enqueue(subscription, event);
               } <span class="keyword">else</span> {
                   invokeSubscriber(subscription, event);
               }
               <span class="keyword">break</span>;
           <span class="keyword">case</span> ASYNC:
               asyncPoster.enqueue(subscription, event);
               <span class="keyword">break</span>;
           <span class="keyword">default</span>:
               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);
       }
   }
</code></pre>
<h3 id="invokeSubscriber-subscription-event"><a href="#invokeSubscriber-subscription-event" class="headerlink" title="invokeSubscriber(subscription, event)"></a>invokeSubscriber(subscription, event)</h3><p>下面我们来分析threadMode = ThreadMode.POSTING的情况,调用invokeSubscriber()方法，其他情况类似。</p>
<pre><code class="java"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>{
        <span class="keyword">try</span> {
            <span class="comment">//反射机制执行订阅的方法</span>
            subscription.subscriberMethod.method.invoke(subscription.subscriber, event);
        } <span class="keyword">catch</span> (InvocationTargetException e) {
            handleSubscriberException(subscription, event, e.getCause());
        } <span class="keyword">catch</span> (IllegalAccessException e) {
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);
        }
    }
</code></pre>
<h3 id="EventBus-getDefault-register-this-小结"><a href="#EventBus-getDefault-register-this-小结" class="headerlink" title="EventBus.getDefault().register(this)小结"></a>EventBus.getDefault().register(this)小结</h3><p>回到苹果公司卖手机的例子，EventBus.getDefault().register(this)中，this指的就是买手机的顾客，顾客通过调用此方法告诉销售部说我想登记买手机，登记的流程包括：<br>A.找到该用户所有的购买手机型号的预约信息(根据subscriber找到所有subscriberMethors<code>subscriberMethodFinder.findSubscriberMethods(subscriberClass)</code>);<br>B.将新登记的预约信息和之前的预约信息做比对，如果之前没有预约信息<code>subscriptions == null</code>，则添加到预约信息中；若之前有预约过的信息，检查是否有相同的预约信息（subscriber和subscriberMethod都一样）<code>subscriptions.contains(newSubscription)</code>，若有，则预约失败,并且丢给用户一个臭脸<code>throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;+ eventType);</code>。<br>C.添加到预约信息列表的时候，根据优先级由高到低，优先级相同插入到最后边的原则放入列表。<br>D.若用户想预约的手机不是新款手机，而是一款老手机<code>subscriberMethod.sticky=ture</code>，则无需预约，可直接购买。</p>
<h2 id="EventBus-getDefault-post-EventType"><a href="#EventBus-getDefault-post-EventType" class="headerlink" title="EventBus.getDefault().post(EventType);"></a>EventBus.getDefault().post(EventType);</h2><h3 id="post-和postSticky-的区别"><a href="#post-和postSticky-的区别" class="headerlink" title="post()和postSticky()的区别"></a>post()和postSticky()的区别</h3><p>发布者调用post(EventType）方法，若订阅者需要接收到此EventType，则订阅者必须要先注册并且注解接收此方法，否则收不到该方法；而调用postSticky(EventType),及时先发布者先发送消息，订阅者在注册事件，也能收到消息。<br>例如苹果公司出iphone8新款手机了，那么用户需要先预约手机，不预约的不能购买，此时苹果公司调用post(iphone8)方法；如果苹果公司推出的是一款旧手机iphone5,iphone5无须预约，顾客到店就可以直接购买，这时候调用postSticky(iphone5)方法。</p>
<h3 id="post-EventType"><a href="#post-EventType" class="headerlink" title="post(EventType);"></a>post(EventType);</h3><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>{
        <span class="comment">//获取当前发送状态</span>
        PostingThreadState postingState = currentPostingThreadState.get();
        List&lt;Object&gt; eventQueue = postingState.eventQueue;
        <span class="comment">//将事件添加到列表中</span>
        eventQueue.add(event);
        <span class="comment">//如果当前不是在发送事件</span>
        <span class="keyword">if</span> (!postingState.isPosting) {
            postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();
            postingState.isPosting = <span class="keyword">true</span>;
            <span class="keyword">if</span> (postingState.canceled) {
                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);
            }
            <span class="keyword">try</span> {
            <span class="comment">//循环发送事件</span>
                <span class="keyword">while</span> (!eventQueue.isEmpty()) {
                    postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);
                }
            } <span class="keyword">finally</span> {
                postingState.isPosting = <span class="keyword">false</span>;
                postingState.isMainThread = <span class="keyword">false</span>;
            }
        }
    }
</code></pre>
<p>将当前发送事件添加到待处理的事件列表，如果当前不是在发送事件状态，则循环事件列表，调用<code>postSingleEvent(eventQueue.remove(0), postingState)</code>发送每一个事件。</p>
<h3 id="postSingleEvent-eventQueue-remove-0-postingState"><a href="#postSingleEvent-eventQueue-remove-0-postingState" class="headerlink" title="postSingleEvent(eventQueue.remove(0), postingState);"></a>postSingleEvent(eventQueue.remove(0), postingState);</h3><pre><code class="java"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>{
       Class&lt;?&gt; eventClass = event.getClass();
       <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;
       <span class="comment">//当需要处理事件的继承关系时</span>
       <span class="keyword">if</span> (eventInheritance) {
           List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);
           <span class="keyword">int</span> countTypes = eventTypes.size();
           <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) {
               Class&lt;?&gt; clazz = eventTypes.get(h);
               subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
           }
       } <span class="keyword">else</span> {
           subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
       }
       <span class="keyword">if</span> (!subscriptionFound) {
           <span class="comment">//没有订阅该事件</span>
           <span class="keyword">if</span> (logNoSubscriberMessages) {
               Log.d(TAG, <span class="string">"No subscribers registered for event "</span> + eventClass);
           }
           <span class="comment">//如果该事件没有subscriber</span>
           <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;
                   eventClass != SubscriberExceptionEvent.class) {
               post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));
           }
       }
   }
</code></pre>
<p>主要处理调用postSingleEventForEventType()遇到的错误。</p>
<h3 id="postSingleEventForEventType"><a href="#postSingleEventForEventType" class="headerlink" title="postSingleEventForEventType()"></a>postSingleEventForEventType()</h3><pre><code class="java"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>{
        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;
        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
        <span class="comment">//根据eventType运行时的类找到所有的subscripitions</span>
            subscriptions = subscriptionsByEventType.get(eventClass);
        }
        <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) {
            <span class="keyword">for</span> (Subscription subscription : subscriptions) {
                postingState.event = event;
                postingState.subscription = subscription;
                <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;
                <span class="keyword">try</span> {
                <span class="comment">//尝试将当前事件发生给订阅了该事件的订阅者</span>
                    postToSubscription(subscription, event, postingState.isMainThread);
                    aborted = postingState.canceled;
                } <span class="keyword">finally</span> {
                    postingState.event = <span class="keyword">null</span>;
                    postingState.subscription = <span class="keyword">null</span>;
                    postingState.canceled = <span class="keyword">false</span>;
                }
                <span class="keyword">if</span> (aborted) {
                    <span class="keyword">break</span>;
                }
            }
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
</code></pre>
<p>以上代码主要是将该事件传递给订阅了该事件的订阅者，每一个订阅者都尝试将该事件作为参数，调用所有的订阅的方法。</p>
<h3 id="post-方法小结"><a href="#post-方法小结" class="headerlink" title="post()方法小结"></a>post()方法小结</h3><p>以上逻辑并不复杂，就直接做比喻好了：<br>苹果公司发布iphone8的流程：<br>A.在发布iphone8的时候，先检查一下iphone8之前的手机是否都已经发布了，将iphone8添加到发布列表中；<br>B.若当前没有手机在发布流程中，则从发布列表中取出接下来待发布的手机，假设iphone8之前的都已经发布，那iphone8就进入发布流程;<br>C.根据iphone8找出所有iphone8的预约信息，预约了iphone8的用户可以购买手机;<br>D.处理特殊的情况：如果没有人预约，或者之前预约的人不购买。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上分析了EventBus的两个主要入口代码，做的比喻可能并不恰当，但应该能对理解源码的逻辑有很大的帮助。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote>
<p><a href="http://p.codekk.com/blogs/detail/54cfab086c4761e5001b2538" target="_blank" rel="external">EventBus 源码解析</a><br><a href="http://skykai521.github.io/2016/02/20/EventBus-3-0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="external">EventBus 3.0 源代码分析</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/17/First设计模式思维导图/" itemprop="url">
                  Head First设计模式思维导图
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-17T20:39:15+08:00" content="2016-10-17">
              2016-10-17
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/10/17/First设计模式思维导图/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/17/First设计模式思维导图/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/10/17/First设计模式思维导图/" class="leancloud_visitors" data-flag-title="Head First设计模式思维导图">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这么多设计模式，看书经常看完后面的就把前面的忘记了。所以在读Head First时，特意边读边做笔记，用思维导图有利于描述设计模式之间的区别和联系。图不是很清晰，可以打开<a href="https://www.processon.com/view/link/57fdf69ae4b08d4fe9b94413" target="_blank" rel="external">Head First设计模式思维导图</a>查看大图。</p>
<p><img src="/images/design.png" alt="Head First设计模式思维导图"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="NEXT" />
          <p class="site-author-name" itemprop="name">NEXT</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NEXT</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"nextb"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("HOe9TkPiadv0Afw5jGl0gEuC-gzGzoHsz", "uPWanKlo8K6iWVB1KIajxCgk");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

</body>
</html>
